/**
 * Mood Detection Engine - Emotional Intelligence for Terminal Interaction
 * 
 * Features:
 * - Typing pattern analysis (speed, pauses, corrections)
 * - Command frequency and error pattern monitoring
 * - Adaptive UI themes and responses
 * - Voice tone analysis (when available)
 * - Smart suggestions based on emotional state
 */

export class MoodDetectionEngine {
    constructor(options = {}) {
        this.options = {
            enableVoiceAnalysis: options.enableVoiceAnalysis !== false,
            enableTypingAnalysis: options.enableTypingAnalysis !== false,
            adaptiveUI: options.adaptiveUI !== false,
            debugMode: options.debugMode === true,
            samplingRate: options.samplingRate || 1000, // ms
            moodUpdateInterval: options.moodUpdateInterval || 5000, // ms
            ...options
        };
        
        // Current emotional state
        this.currentMood = 'neutral';
        this.confidence = 0.5;
        this.moodHistory = [];
        
        // Typing pattern analysis
        this.typingMetrics = {
            keystrokes: [],
            averageWPM: 0,
            pauseCount: 0,
            correctionCount: 0,
            rapidFireEvents: 0,
            lastKeystroke: null
        };
        
        // Command pattern analysis
        this.commandMetrics = {
            commandHistory: [],
            errorStreaks: 0,
            successStreak: 0,
            repeatCommands: 0,
            helpRequests: 0,
            frustrationType: 'none' // none, syntax, system, navigation
        };
        
        // Voice analysis (if available)
        this.voiceMetrics = {
            enabled: false,
            audioContext: null,
            analyser: null,
            toneIndicators: {
                pitch: 0,
                volume: 0,
                speed: 0
            }
        };
        
        // UI adaptation state
        this.uiState = {
            theme: 'default',
            glowIntensity: 0.5,
            suggestionLevel: 'normal', // minimal, normal, helpful, verbose
            colorPalette: 'neutral'
        };
        
        // Event handlers
        this.handlers = {
            moodChange: [],
            confidenceChange: [],
            uiAdaptation: []
        };
        
        // Initialize components
        this.initializeTypingAnalysis();
        
        if (this.options.enableVoiceAnalysis) {
            this.initializeVoiceAnalysis();
        }
        
        // Start mood analysis loop
        this.startMoodAnalysis();
        
        this.log('Mood Detection Engine initialized', 'info');
    }
    
    /**
     * Initialize typing pattern analysis
     */
    initializeTypingAnalysis() {
        if (!this.options.enableTypingAnalysis) return;
        
        // Monitor global keystrokes
        document.addEventListener('keydown', (e) => {
            this.recordKeystroke(e);
        });
        
        // Monitor terminal-specific events if terminal is available
        this.monitorTerminalInput();
        
        this.log('Typing analysis initialized', 'info');
    }
    
    /**
     * Record keystroke for analysis
     */
    recordKeystroke(event) {
        const now = Date.now();
        const keystroke = {
            timestamp: now,
            key: event.key,
            code: event.code,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            metaKey: event.metaKey,
            repeat: event.repeat
        };
        
        this.typingMetrics.keystrokes.push(keystroke);\n        \n        // Analyze typing patterns\n        this.analyzeTypingPattern(keystroke);\n        \n        // Keep only recent keystrokes (last 30 seconds)\n        const cutoff = now - 30000;\n        this.typingMetrics.keystrokes = this.typingMetrics.keystrokes.filter(\n            k => k.timestamp > cutoff\n        );\n    }\n    \n    /**\n     * Analyze typing patterns for mood indicators\n     */\n    analyzeTypingPattern(keystroke) {\n        const now = Date.now();\n        \n        // Calculate time between keystrokes\n        if (this.typingMetrics.lastKeystroke) {\n            const timeDelta = now - this.typingMetrics.lastKeystroke.timestamp;\n            \n            // Detect rapid-fire typing (possible urgency/frustration)\n            if (timeDelta < 100) {\n                this.typingMetrics.rapidFireEvents++;\n            }\n            \n            // Detect long pauses (possible confusion/thinking)\n            if (timeDelta > 2000) {\n                this.typingMetrics.pauseCount++;\n            }\n        }\n        \n        // Detect corrections (backspace/delete)\n        if (keystroke.key === 'Backspace' || keystroke.key === 'Delete') {\n            this.typingMetrics.correctionCount++;\n        }\n        \n        // Calculate WPM\n        this.calculateWPM();\n        \n        this.typingMetrics.lastKeystroke = keystroke;\n    }\n    \n    /**\n     * Calculate words per minute\n     */\n    calculateWPM() {\n        const now = Date.now();\n        const oneMinuteAgo = now - 60000;\n        \n        const recentKeystrokes = this.typingMetrics.keystrokes.filter(\n            k => k.timestamp > oneMinuteAgo && k.key.length === 1\n        );\n        \n        // Rough WPM calculation (5 characters = 1 word)\n        this.typingMetrics.averageWPM = Math.round(recentKeystrokes.length / 5);\n    }\n    \n    /**\n     * Monitor terminal input for command patterns\n     */\n    monitorTerminalInput() {\n        // Hook into shell manager if available\n        const checkShellManager = () => {\n            const shellManager = window.diagnosticState?.shellManager;\n            if (shellManager) {\n                shellManager.on('data', (data) => {\n                    if (data.direction === 'sent') {\n                        this.analyzeCommand(data.data);\n                    } else {\n                        this.analyzeCommandResponse(data.data);\n                    }\n                });\n                \n                shellManager.on('error', (error) => {\n                    this.recordCommandError(error);\n                });\n                \n                this.log('Terminal input monitoring active', 'info');\n                return true;\n            }\n            return false;\n        };\n        \n        // Try to connect now, or retry periodically\n        if (!checkShellManager()) {\n            const retryInterval = setInterval(() => {\n                if (checkShellManager()) {\n                    clearInterval(retryInterval);\n                }\n            }, 2000);\n        }\n    }\n    \n    /**\n     * Analyze command for mood indicators\n     */\n    analyzeCommand(command) {\n        const cleanCommand = command.trim().toLowerCase();\n        \n        if (!cleanCommand || cleanCommand === '\\r') return;\n        \n        const commandEntry = {\n            timestamp: Date.now(),\n            command: cleanCommand,\n            type: this.categorizeCommand(cleanCommand)\n        };\n        \n        this.commandMetrics.commandHistory.push(commandEntry);\n        \n        // Keep only recent commands (last 100)\n        if (this.commandMetrics.commandHistory.length > 100) {\n            this.commandMetrics.commandHistory.shift();\n        }\n        \n        // Detect patterns\n        this.detectCommandPatterns(commandEntry);\n    }\n    \n    /**\n     * Categorize command type\n     */\n    categorizeCommand(command) {\n        const helpCommands = ['help', 'man', '--help', '-h', '?'];\n        const navigationCommands = ['cd', 'ls', 'pwd', 'find', 'locate'];\n        const fileCommands = ['cat', 'nano', 'vim', 'emacs', 'touch', 'mkdir'];\n        const systemCommands = ['ps', 'kill', 'top', 'htop', 'df', 'free'];\n        \n        if (helpCommands.some(h => command.includes(h))) return 'help';\n        if (navigationCommands.some(n => command.startsWith(n))) return 'navigation';\n        if (fileCommands.some(f => command.startsWith(f))) return 'file';\n        if (systemCommands.some(s => command.startsWith(s))) return 'system';\n        \n        return 'other';\n    }\n    \n    /**\n     * Detect command patterns that indicate mood\n     */\n    detectCommandPatterns(commandEntry) {\n        const recent = this.commandMetrics.commandHistory.slice(-5);\n        \n        // Detect help-seeking behavior (confusion/learning)\n        if (commandEntry.type === 'help') {\n            this.commandMetrics.helpRequests++;\n        }\n        \n        // Detect repeated commands (possible frustration)\n        const lastCommands = recent.map(c => c.command);\n        const duplicates = lastCommands.filter((cmd, i) => \n            lastCommands.indexOf(cmd) !== i\n        ).length;\n        \n        if (duplicates > 0) {\n            this.commandMetrics.repeatCommands++;\n        }\n    }\n    \n    /**\n     * Analyze command response for errors\n     */\n    analyzeCommandResponse(response) {\n        const errorIndicators = [\n            'command not found',\n            'no such file',\n            'permission denied',\n            'syntax error',\n            'invalid option',\n            'cannot access'\n        ];\n        \n        const isError = errorIndicators.some(indicator => \n            response.toLowerCase().includes(indicator)\n        );\n        \n        if (isError) {\n            this.recordCommandError({ message: response });\n        } else {\n            // Reset error streak on success\n            if (this.commandMetrics.errorStreaks > 0) {\n                this.commandMetrics.errorStreaks = 0;\n                this.commandMetrics.successStreak++;\n            }\n        }\n    }\n    \n    /**\n     * Record command error for mood analysis\n     */\n    recordCommandError(error) {\n        this.commandMetrics.errorStreaks++;\n        this.commandMetrics.successStreak = 0;\n        \n        // Categorize frustration type\n        const errorMsg = error.message.toLowerCase();\n        if (errorMsg.includes('syntax') || errorMsg.includes('invalid')) {\n            this.commandMetrics.frustrationType = 'syntax';\n        } else if (errorMsg.includes('permission') || errorMsg.includes('access')) {\n            this.commandMetrics.frustrationType = 'system';\n        } else if (errorMsg.includes('not found') || errorMsg.includes('no such')) {\n            this.commandMetrics.frustrationType = 'navigation';\n        }\n    }\n    \n    /**\n     * Initialize voice analysis (experimental)\n     */\n    async initializeVoiceAnalysis() {\n        try {\n            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n                this.log('Voice analysis not supported in this browser', 'warning');\n                return;\n            }\n            \n            // Request microphone access\n            const stream = await navigator.mediaDevices.getUserMedia({ \n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    sampleRate: 44100\n                }\n            });\n            \n            // Set up audio analysis\n            this.voiceMetrics.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            this.voiceMetrics.analyser = this.voiceMetrics.audioContext.createAnalyser();\n            \n            const source = this.voiceMetrics.audioContext.createMediaStreamSource(stream);\n            source.connect(this.voiceMetrics.analyser);\n            \n            this.voiceMetrics.analyser.fftSize = 2048;\n            this.voiceMetrics.enabled = true;\n            \n            // Start voice analysis loop\n            this.startVoiceAnalysis();\n            \n            this.log('Voice analysis initialized', 'success');\n            \n        } catch (error) {\n            this.log(`Voice analysis initialization failed: ${error.message}`, 'warning');\n        }\n    }\n    \n    /**\n     * Start voice analysis loop\n     */\n    startVoiceAnalysis() {\n        if (!this.voiceMetrics.enabled) return;\n        \n        const analyzeVoice = () => {\n            const bufferLength = this.voiceMetrics.analyser.frequencyBinCount;\n            const dataArray = new Uint8Array(bufferLength);\n            \n            this.voiceMetrics.analyser.getByteFrequencyData(dataArray);\n            \n            // Calculate voice metrics\n            const average = dataArray.reduce((a, b) => a + b) / bufferLength;\n            const volume = average / 255;\n            \n            // Simple pitch detection (fundamental frequency)\n            let maxIndex = 0;\n            let maxValue = 0;\n            for (let i = 0; i < bufferLength; i++) {\n                if (dataArray[i] > maxValue) {\n                    maxValue = dataArray[i];\n                    maxIndex = i;\n                }\n            }\n            \n            const pitch = maxIndex * this.voiceMetrics.audioContext.sampleRate / (2 * bufferLength);\n            \n            // Update voice metrics\n            this.voiceMetrics.toneIndicators = {\n                volume: volume,\n                pitch: pitch,\n                energy: average\n            };\n            \n            requestAnimationFrame(analyzeVoice);\n        };\n        \n        analyzeVoice();\n    }\n    \n    /**\n     * Start mood analysis loop\n     */\n    startMoodAnalysis() {\n        setInterval(() => {\n            this.analyzeMood();\n        }, this.options.moodUpdateInterval);\n        \n        this.log('Mood analysis loop started', 'info');\n    }\n    \n    /**\n     * Main mood analysis function\n     */\n    analyzeMood() {\n        const moodScores = {\n            frustrated: 0,\n            confused: 0,\n            confident: 0,\n            curious: 0,\n            overwhelmed: 0,\n            focused: 0\n        };\n        \n        // Analyze typing patterns\n        this.analyzeTypingMood(moodScores);\n        \n        // Analyze command patterns\n        this.analyzeCommandMood(moodScores);\n        \n        // Analyze voice patterns (if available)\n        if (this.voiceMetrics.enabled) {\n            this.analyzeVoiceMood(moodScores);\n        }\n        \n        // Determine dominant mood\n        const newMood = this.calculateDominantMood(moodScores);\n        const newConfidence = this.calculateConfidence(moodScores);\n        \n        // Update mood if significantly changed\n        if (newMood !== this.currentMood || Math.abs(newConfidence - this.confidence) > 0.1) {\n            this.updateMood(newMood, newConfidence);\n        }\n        \n        // Store mood history\n        this.moodHistory.push({\n            timestamp: Date.now(),\n            mood: this.currentMood,\n            confidence: this.confidence,\n            scores: { ...moodScores }\n        });\n        \n        // Keep only recent history (last hour)\n        const oneHourAgo = Date.now() - 3600000;\n        this.moodHistory = this.moodHistory.filter(h => h.timestamp > oneHourAgo);\n    }\n    \n    /**\n     * Analyze typing patterns for mood indicators\n     */\n    analyzeTypingMood(moodScores) {\n        const metrics = this.typingMetrics;\n        \n        // High correction rate suggests frustration\n        if (metrics.correctionCount > 5) {\n            moodScores.frustrated += 0.3;\n        }\n        \n        // Rapid-fire typing suggests urgency/frustration\n        if (metrics.rapidFireEvents > 3) {\n            moodScores.frustrated += 0.2;\n            moodScores.overwhelmed += 0.1;\n        }\n        \n        // Long pauses suggest confusion or thinking\n        if (metrics.pauseCount > 3) {\n            moodScores.confused += 0.2;\n            moodScores.curious += 0.1;\n        }\n        \n        // Steady WPM suggests focus\n        if (metrics.averageWPM > 30 && metrics.averageWPM < 80) {\n            moodScores.focused += 0.2;\n            moodScores.confident += 0.1;\n        }\n        \n        // Very high WPM might suggest stress\n        if (metrics.averageWPM > 100) {\n            moodScores.overwhelmed += 0.2;\n        }\n    }\n    \n    /**\n     * Analyze command patterns for mood indicators\n     */\n    analyzeCommandMood(moodScores) {\n        const metrics = this.commandMetrics;\n        \n        // Error streaks suggest frustration\n        if (metrics.errorStreaks > 2) {\n            moodScores.frustrated += 0.4;\n        }\n        \n        if (metrics.errorStreaks > 5) {\n            moodScores.overwhelmed += 0.3;\n        }\n        \n        // Help requests suggest confusion or curiosity\n        if (metrics.helpRequests > 2) {\n            moodScores.confused += 0.2;\n            moodScores.curious += 0.3;\n        }\n        \n        // Repeated commands suggest frustration\n        if (metrics.repeatCommands > 3) {\n            moodScores.frustrated += 0.2;\n        }\n        \n        // Success streaks suggest confidence\n        if (metrics.successStreak > 3) {\n            moodScores.confident += 0.3;\n            moodScores.focused += 0.2;\n        }\n        \n        // Different frustration types\n        if (metrics.frustrationType === 'syntax') {\n            moodScores.confused += 0.1;\n        } else if (metrics.frustrationType === 'system') {\n            moodScores.frustrated += 0.2;\n        }\n    }\n    \n    /**\n     * Analyze voice patterns for mood indicators\n     */\n    analyzeVoiceMood(moodScores) {\n        const voice = this.voiceMetrics.toneIndicators;\n        \n        // High volume might suggest frustration or excitement\n        if (voice.volume > 0.7) {\n            moodScores.frustrated += 0.2;\n        }\n        \n        // Low volume might suggest confusion or timidity\n        if (voice.volume < 0.2 && voice.volume > 0.05) {\n            moodScores.confused += 0.1;\n        }\n        \n        // High pitch might suggest stress or excitement\n        if (voice.pitch > 300) {\n            moodScores.overwhelmed += 0.1;\n        }\n        \n        // Moderate energy suggests focus\n        if (voice.energy > 30 && voice.energy < 80) {\n            moodScores.focused += 0.1;\n        }\n    }\n    \n    /**\n     * Calculate dominant mood from scores\n     */\n    calculateDominantMood(scores) {\n        let maxScore = 0;\n        let dominantMood = 'neutral';\n        \n        for (const [mood, score] of Object.entries(scores)) {\n            if (score > maxScore) {\n                maxScore = score;\n                dominantMood = mood;\n            }\n        }\n        \n        // Require minimum threshold for mood change\n        return maxScore > 0.3 ? dominantMood : 'neutral';\n    }\n    \n    /**\n     * Calculate confidence level\n     */\n    calculateConfidence(scores) {\n        const values = Object.values(scores);\n        const max = Math.max(...values);\n        const secondMax = values.sort((a, b) => b - a)[1] || 0;\n        \n        // Higher confidence when there's a clear dominant mood\n        return Math.min(0.9, Math.max(0.1, (max - secondMax) + 0.3));\n    }\n    \n    /**\n     * Update current mood and trigger adaptations\n     */\n    updateMood(newMood, newConfidence) {\n        const oldMood = this.currentMood;\n        this.currentMood = newMood;\n        this.confidence = newConfidence;\n        \n        this.log(`Mood changed: ${oldMood} → ${newMood} (${Math.round(newConfidence * 100)}% confidence)`, 'info');\n        \n        // Emit mood change event\n        this.emit('moodChange', {\n            oldMood,\n            newMood,\n            confidence: newConfidence\n        });\n        \n        // Trigger UI adaptations\n        if (this.options.adaptiveUI) {\n            this.adaptUI();\n        }\n        \n        // Update UI metric display\n        this.updateMoodDisplay();\n    }\n    \n    /**\n     * Adapt UI based on current mood\n     */\n    adaptUI() {\n        const adaptations = this.getUIAdaptations(this.currentMood);\n        \n        // Apply color theme\n        if (adaptations.colorPalette !== this.uiState.colorPalette) {\n            this.applyColorTheme(adaptations.colorPalette);\n        }\n        \n        // Apply glow effects\n        if (adaptations.glowIntensity !== this.uiState.glowIntensity) {\n            this.applyGlowEffects(adaptations.glowIntensity);\n        }\n        \n        // Update suggestion level\n        this.uiState.suggestionLevel = adaptations.suggestionLevel;\n        \n        this.uiState = { ...this.uiState, ...adaptations };\n        \n        // Emit UI adaptation event\n        this.emit('uiAdaptation', adaptations);\n        \n        this.log(`UI adapted for ${this.currentMood} mood`, 'info');\n    }\n    \n    /**\n     * Get UI adaptations for a specific mood\n     */\n    getUIAdaptations(mood) {\n        const adaptations = {\n            frustrated: {\n                colorPalette: 'calm',\n                glowIntensity: 0.3,\n                suggestionLevel: 'helpful',\n                theme: 'soothing'\n            },\n            confused: {\n                colorPalette: 'warm',\n                glowIntensity: 0.4,\n                suggestionLevel: 'verbose',\n                theme: 'educational'\n            },\n            confident: {\n                colorPalette: 'vibrant',\n                glowIntensity: 0.7,\n                suggestionLevel: 'minimal',\n                theme: 'dynamic'\n            },\n            curious: {\n                colorPalette: 'cool',\n                glowIntensity: 0.6,\n                suggestionLevel: 'normal',\n                theme: 'explorative'\n            },\n            overwhelmed: {\n                colorPalette: 'muted',\n                glowIntensity: 0.2,\n                suggestionLevel: 'simplified',\n                theme: 'minimal'\n            },\n            focused: {\n                colorPalette: 'monochrome',\n                glowIntensity: 0.4,\n                suggestionLevel: 'minimal',\n                theme: 'focused'\n            }\n        };\n        \n        return adaptations[mood] || {\n            colorPalette: 'neutral',\n            glowIntensity: 0.5,\n            suggestionLevel: 'normal',\n            theme: 'default'\n        };\n    }\n    \n    /**\n     * Apply color theme to UI\n     */\n    applyColorTheme(palette) {\n        const themes = {\n            calm: {\n                primary: '#4fc3f7',\n                accent: '#81c784',\n                background: '#1a237e',\n                glow: '#4fc3f7'\n            },\n            warm: {\n                primary: '#ffb74d',\n                accent: '#ff8a65',\n                background: '#3e2723',\n                glow: '#ffb74d'\n            },\n            vibrant: {\n                primary: '#e91e63',\n                accent: '#00e676',\n                background: '#1a1a1a',\n                glow: '#e91e63'\n            },\n            cool: {\n                primary: '#26c6da',\n                accent: '#7c4dff',\n                background: '#0d47a1',\n                glow: '#26c6da'\n            },\n            muted: {\n                primary: '#90a4ae',\n                accent: '#a1887f',\n                background: '#212121',\n                glow: '#90a4ae'\n            },\n            monochrome: {\n                primary: '#ffffff',\n                accent: '#b0bec5',\n                background: '#000000',\n                glow: '#ffffff'\n            }\n        };\n        \n        const theme = themes[palette] || themes.neutral;\n        \n        // Apply CSS custom properties\n        const root = document.documentElement;\n        root.style.setProperty('--mood-primary', theme.primary);\n        root.style.setProperty('--mood-accent', theme.accent);\n        root.style.setProperty('--mood-background', theme.background);\n        root.style.setProperty('--mood-glow', theme.glow);\n    }\n    \n    /**\n     * Apply glow effects\n     */\n    applyGlowEffects(intensity) {\n        const elements = document.querySelectorAll('.terminal-container, .control-panel');\n        \n        elements.forEach(element => {\n            const glowColor = getComputedStyle(document.documentElement)\n                .getPropertyValue('--mood-glow') || '#00ff88';\n            \n            const shadowIntensity = Math.round(intensity * 20);\n            element.style.boxShadow = `0 0 ${shadowIntensity}px ${glowColor}33`;\n        });\n    }\n    \n    /**\n     * Update mood display in UI\n     */\n    updateMoodDisplay() {\n        if (typeof updateMetric === 'function') {\n            const moodEmojis = {\n                frustrated: '😤',\n                confused: '🤔',\n                confident: '😎',\n                curious: '🤓',\n                overwhelmed: '😵',\n                focused: '🎯',\n                neutral: '😐'\n            };\n            \n            const displayText = `${moodEmojis[this.currentMood]} ${this.currentMood.charAt(0).toUpperCase() + this.currentMood.slice(1)}`;\n            const confidenceClass = this.confidence > 0.7 ? 'success' : this.confidence > 0.4 ? 'warning' : 'info';\n            \n            updateMetric('mood-status', displayText, confidenceClass);\n        }\n    }\n    \n    /**\n     * Get smart suggestions based on current mood\n     */\n    getSmartSuggestions() {\n        const suggestions = {\n            frustrated: [\n                \"Take a deep breath. Try 'history | grep <command>' to find previous commands.\",\n                \"Maybe try 'man <command>' for detailed help?\",\n                \"Consider breaking this down into smaller steps.\"\n            ],\n            confused: [\n                \"Need help? Try 'help' or 'man <command>' for documentation.\",\n                \"Use 'ls -la' to see what files are available.\",\n                \"Try 'pwd' to see where you are in the filesystem.\"\n            ],\n            confident: [\n                \"You're on fire! 🔥\",\n                \"Ready for a challenge? Try some advanced commands.\",\n                \"Great job! Keep up the momentum.\"\n            ],\n            curious: [\n                \"Exploring is great! Try 'find . -name \"*pattern*\"' to search for files.\",\n                \"Use 'which <command>' to see where programs are located.\",\n                \"Check out 'env' to see your environment variables.\"\n            ],\n            overwhelmed: [\n                \"Let's take this one step at a time.\",\n                \"Focus on one task. You've got this! 💪\",\n                \"Try 'clear' to clean up your screen.\"\n            ],\n            focused: [\n                \"You're in the zone! 🎯\",\n                \"Great concentration. Keep going!\",\n                \"Productivity mode: ON\"\n            ]\n        };\n        \n        const moodSuggestions = suggestions[this.currentMood] || [\n            \"How can I help you today?\",\n            \"Ready to work on something interesting?\"\n        ];\n        \n        return moodSuggestions[Math.floor(Math.random() * moodSuggestions.length)];\n    }\n    \n    /**\n     * Get current mood state\n     */\n    getMoodState() {\n        return {\n            mood: this.currentMood,\n            confidence: this.confidence,\n            uiState: this.uiState,\n            suggestions: this.getSmartSuggestions(),\n            metrics: {\n                typing: this.typingMetrics,\n                commands: this.commandMetrics,\n                voice: this.voiceMetrics.enabled ? this.voiceMetrics.toneIndicators : null\n            }\n        };\n    }\n    \n    /**\n     * Event emitter functionality\n     */\n    on(event, handler) {\n        if (!this.handlers[event]) {\n            this.handlers[event] = [];\n        }\n        this.handlers[event].push(handler);\n    }\n    \n    emit(event, data) {\n        if (this.handlers[event]) {\n            this.handlers[event].forEach(handler => {\n                try {\n                    handler(data);\n                } catch (error) {\n                    this.log(`Event handler error for ${event}: ${error.message}`, 'error');\n                }\n            });\n        }\n    }\n    \n    /**\n     * Reset mood detection state\n     */\n    reset() {\n        this.currentMood = 'neutral';\n        this.confidence = 0.5;\n        this.moodHistory = [];\n        this.typingMetrics = {\n            keystrokes: [],\n            averageWPM: 0,\n            pauseCount: 0,\n            correctionCount: 0,\n            rapidFireEvents: 0,\n            lastKeystroke: null\n        };\n        this.commandMetrics = {\n            commandHistory: [],\n            errorStreaks: 0,\n            successStreak: 0,\n            repeatCommands: 0,\n            helpRequests: 0,\n            frustrationType: 'none'\n        };\n        \n        this.log('Mood detection state reset', 'info');\n    }\n    \n    /**\n     * Logging utility\n     */\n    log(message, level = 'info') {\n        const prefix = '[MoodEngine]';\n        \n        if (this.options.debugMode) {\n            console[level === 'error' ? 'error' : level === 'warning' ? 'warn' : 'log'](`${prefix} ${message}`);\n        }\n        \n        // Use global logMessage if available\n        if (typeof window !== 'undefined' && window.logMessage) {\n            window.logMessage(`${prefix} ${message}`, level);\n        }\n    }\n    \n    /**\n     * Cleanup resources\n     */\n    destroy() {\n        // Stop voice analysis\n        if (this.voiceMetrics.audioContext) {\n            this.voiceMetrics.audioContext.close();\n        }\n        \n        // Clear handlers\n        this.handlers = {\n            moodChange: [],\n            confidenceChange: [],\n            uiAdaptation: []\n        };\n        \n        this.log('Mood detection engine destroyed', 'info');\n    }\n}\n\n/**\n * Factory function to create mood detection engine\n */\nexport function createMoodDetectionEngine(options = {}) {\n    return new MoodDetectionEngine(options);\n}\n\n/**\n * Global mood detection instance\n */\nexport let globalMoodEngine = null;\n\n/**\n * Initialize global mood detection\n */\nexport function initializeGlobalMoodDetection(options = {}) {\n    if (globalMoodEngine) {\n        globalMoodEngine.destroy();\n    }\n    \n    globalMoodEngine = createMoodDetectionEngine(options);\n    \n    // Make available globally\n    if (typeof window !== 'undefined') {\n        window.moodEngine = globalMoodEngine;\n    }\n    \n    return globalMoodEngine;\n}"
