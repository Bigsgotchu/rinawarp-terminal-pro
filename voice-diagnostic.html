<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RinaWarp Voice Diagnostic</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #2d2d2d;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            font-weight: bold;
        }
        .success { background-color: #4CAF50; color: white; }
        .error { background-color: #f44336; color: white; }
        .warning { background-color: #ff9800; color: white; }
        .info { background-color: #2196F3; color: white; }
        button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #005a9e;
        }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        #transcription {
            background-color: #333;
            border: 1px solid #555;
            padding: 10px;
            margin: 10px 0;
            min-height: 50px;
            border-radius: 5px;
        }
        .indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #f44336;
            margin-right: 10px;
        }
        .indicator.active {
            background-color: #4CAF50;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <h1>üé§ RinaWarp Voice Diagnostic Tool</h1>
    
    <div class="test-section">
        <h2>1. Browser Compatibility Check</h2>
        <div id="browserCheck"></div>
    </div>
    
    <div class="test-section">
        <h2>2. Microphone Permission Test</h2>
        <button onclick="testMicrophonePermission()">Test Microphone Access</button>
        <div id="microphoneStatus"></div>
    </div>
    
    <div class="test-section">
        <h2>3. Speech Recognition Test</h2>
        <button onclick="testSpeechRecognition()" id="speechButton">Start Speech Recognition</button>
        <div id="speechStatus"></div>
        <div id="transcription"></div>
    </div>
    
    <div class="test-section">
        <h2>4. Voice Recording Test</h2>
        <button onclick="testVoiceRecording()" id="recordButton">Start Recording</button>
        <button onclick="stopRecording()" id="stopButton" disabled>Stop Recording</button>
        <button onclick="playRecording()" id="playButton" disabled>Play Recording</button>
        <div id="recordingStatus"></div>
    </div>
    
    <div class="test-section">
        <h2>5. System Information</h2>
        <div id="systemInfo"></div>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let recognition;
        let isListening = false;
        let audioBlob;

        // Check browser compatibility
        function checkBrowserCompatibility() {
            const results = [];
            
            // Check for Speech Recognition API
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                results.push({ test: 'Speech Recognition API', status: 'success', message: 'Supported' });
            } else {
                results.push({ test: 'Speech Recognition API', status: 'error', message: 'Not supported' });
            }
            
            // Check for MediaDevices API
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                results.push({ test: 'MediaDevices API', status: 'success', message: 'Supported' });
            } else {
                results.push({ test: 'MediaDevices API', status: 'error', message: 'Not supported' });
            }
            
            // Check for MediaRecorder API
            if (window.MediaRecorder) {
                results.push({ test: 'MediaRecorder API', status: 'success', message: 'Supported' });
            } else {
                results.push({ test: 'MediaRecorder API', status: 'error', message: 'Not supported' });
            }
            
            // Check for Web Audio API
            if (window.AudioContext || window.webkitAudioContext) {
                results.push({ test: 'Web Audio API', status: 'success', message: 'Supported' });
            } else {
                results.push({ test: 'Web Audio API', status: 'error', message: 'Not supported' });
            }
            
            return results;
        }

        // Test microphone permission
        async function testMicrophonePermission() {
            const statusDiv = document.getElementById('microphoneStatus');
            statusDiv.innerHTML = '<div class="status info">Testing microphone access...</div>';
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                statusDiv.innerHTML = '<div class="status success">‚úÖ Microphone access granted!</div>';
                
                // Get audio device info
                const tracks = stream.getAudioTracks();
                if (tracks.length > 0) {
                    const track = tracks[0];
                    statusDiv.innerHTML += `<div class="status info">üì± Device: ${track.label || 'Default microphone'}</div>`;
                    statusDiv.innerHTML += `<div class="status info">üéõÔ∏è Settings: ${JSON.stringify(track.getSettings(), null, 2)}</div>`;
                }
                
                // Stop the stream
                stream.getTracks().forEach(track => track.stop());
                
            } catch (error) {
                let errorMessage = 'Unknown error';
                switch(error.name) {
                    case 'NotAllowedError':
                        errorMessage = 'Microphone access denied. Please allow microphone access in your browser settings.';
                        break;
                    case 'NotFoundError':
                        errorMessage = 'No microphone found. Please check your microphone connection.';
                        break;
                    case 'NotReadableError':
                        errorMessage = 'Microphone is being used by another application.';
                        break;
                    case 'OverconstrainedError':
                        errorMessage = 'Microphone constraints could not be satisfied.';
                        break;
                    case 'SecurityError':
                        errorMessage = 'Security error. HTTPS may be required.';
                        break;
                    default:
                        errorMessage = error.message;
                }
                statusDiv.innerHTML = `<div class="status error">‚ùå Error: ${errorMessage}</div>`;
            }
        }

        // Test speech recognition
        function testSpeechRecognition() {
            const statusDiv = document.getElementById('speechStatus');
            const transcriptionDiv = document.getElementById('transcription');
            const button = document.getElementById('speechButton');
            
            if (isListening) {
                recognition.stop();
                return;
            }
            
            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 3;
                
                recognition.onstart = () => {
                    isListening = true;
                    button.textContent = 'Stop Listening';
                    statusDiv.innerHTML = '<div class="status success"><span class="indicator active"></span>Listening...</div>';
                };
                
                recognition.onresult = (event) => {
                    let interim = '';
                    let final = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        const confidence = event.results[i][0].confidence;
                        
                        if (event.results[i].isFinal) {
                            final += transcript;
                        } else {
                            interim += transcript;
                        }
                    }
                    
                    transcriptionDiv.innerHTML = `
                        <div><strong>Final:</strong> ${final}</div>
                        <div><strong>Interim:</strong> ${interim}</div>
                    `;
                };
                
                recognition.onerror = (event) => {
                    let errorMessage = event.error;
                    switch(event.error) {
                        case 'not-allowed':
                            errorMessage = 'Microphone access denied';
                            break;
                        case 'network':
                            errorMessage = 'Network error - check internet connection';
                            break;
                        case 'no-speech':
                            errorMessage = 'No speech detected';
                            break;
                        case 'audio-capture':
                            errorMessage = 'Audio capture failed';
                            break;
                        case 'service-not-allowed':
                            errorMessage = 'Speech service not allowed';
                            break;
                    }
                    statusDiv.innerHTML = `<div class="status error">‚ùå Error: ${errorMessage}</div>`;
                };
                
                recognition.onend = () => {
                    isListening = false;
                    button.textContent = 'Start Speech Recognition';
                    statusDiv.innerHTML = '<div class="status info">Speech recognition stopped</div>';
                };
                
                recognition.start();
                
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Speech Recognition Error: ${error.message}</div>`;
            }
        }

        // Test voice recording
        async function testVoiceRecording() {
            const statusDiv = document.getElementById('recordingStatus');
            const recordButton = document.getElementById('recordButton');
            const stopButton = document.getElementById('stopButton');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    document.getElementById('playButton').disabled = false;
                    statusDiv.innerHTML = '<div class="status success">‚úÖ Recording completed!</div>';
                };
                
                mediaRecorder.start();
                recordButton.disabled = true;
                stopButton.disabled = false;
                statusDiv.innerHTML = '<div class="status info"><span class="indicator active"></span>Recording...</div>';
                
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Recording Error: ${error.message}</div>`;
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                document.getElementById('recordButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
            }
        }

        function playRecording() {
            if (audioBlob) {
                const audio = new Audio(URL.createObjectURL(audioBlob));
                audio.play();
                document.getElementById('recordingStatus').innerHTML += '<div class="status info">üîä Playing recording...</div>';
            }
        }

        // Get system information
        function getSystemInfo() {
            const info = {
                'User Agent': navigator.userAgent,
                'Platform': navigator.platform,
                'Language': navigator.language,
                'Online': navigator.onLine,
                'Cookie Enabled': navigator.cookieEnabled,
                'Protocol': location.protocol,
                'Host': location.host,
                'Is Electron': typeof require !== 'undefined' && typeof process !== 'undefined' && process.versions && process.versions.electron
            };
            
            return info;
        }

        // Initialize diagnostics
        function initDiagnostics() {
            // Browser compatibility
            const browserResults = checkBrowserCompatibility();
            const browserDiv = document.getElementById('browserCheck');
            browserDiv.innerHTML = browserResults.map(result => 
                `<div class="status ${result.status}">${result.test}: ${result.message}</div>`
            ).join('');
            
            // System information
            const systemInfo = getSystemInfo();
            const systemDiv = document.getElementById('systemInfo');
            systemDiv.innerHTML = Object.entries(systemInfo).map(([key, value]) => 
                `<div class="status info"><strong>${key}:</strong> ${value}</div>`
            ).join('');
        }

        // Run diagnostics on page load
        document.addEventListener('DOMContentLoaded', initDiagnostics);
    </script>
</body>
</html>
