<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RinaWarp Terminal - Robust Edition</title>
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --border: #444;
            --text-primary: #fff;
            --text-secondary: #aaa;
            --accent-success: #51cf66;
            --accent-warning: #ffd93d;
            --accent-error: #ff6b6b;
            --accent-info: #74c0fc;
        }

        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Consolas', 'Courier New', monospace;
            overflow: hidden;
        }
        
        .title-bar {
            height: 35px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            -webkit-app-region: drag;
        }
        
        .title-bar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .app-logo {
            font-size: 16px;
        }
        
        .title-bar-title {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .system-status {
            display: flex;
            gap: 15px;
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 4px;
        }
        
        .status-dot.green { background: var(--accent-success); }
        .status-dot.yellow { background: var(--accent-warning); }
        .status-dot.red { background: var(--accent-error); }
        .status-dot.blue { background: var(--accent-info); }
        
        .title-bar-controls {
            display: flex;
            gap: 8px;
            -webkit-app-region: no-drag;
        }
        
        .tab-bar {
            height: 35px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 10px;
            overflow-x: auto;
            scrollbar-width: thin;
        }
        
        .tab-bar::-webkit-scrollbar {
            height: 4px;
        }
        
        .tab-bar::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        .tab-bar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }
        
        .tab {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-bottom: none;
            margin-right: 2px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s;
            min-width: 120px;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tab.active {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-bottom: 2px solid var(--accent-info);
        }
        
        .tab:hover:not(.active) {
            background: rgba(116, 192, 252, 0.1);
            color: var(--text-primary);
        }
        
        .tab-title {
            flex: 1;
            margin-right: 8px;
        }
        
        .tab-close {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.2s;
        }
        
        .tab-close:hover {
            background: var(--accent-error);
            color: #fff;
        }
        
        .tab-add {
            padding: 8px 12px;
            background: transparent;
            border: 1px dashed var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            margin-left: 10px;
        }
        
        .tab-add:hover {
            background: rgba(116, 192, 252, 0.1);
            color: var(--accent-info);
            border-color: var(--accent-info);
        }
        
        .title-bar-control {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .title-bar-control:hover { opacity: 0.8; }
        .title-bar-control:nth-child(1) { background: #ff5f56; }
        .title-bar-control:nth-child(2) { background: #ffbd2e; }
        .title-bar-control:nth-child(3) { background: #27ca3f; }
        
        .main-container {
            height: calc(100vh - 35px);
            display: flex;
            flex-direction: column;
        }
        
        .triage-banner {
            background: var(--bg-secondary);
            color: #000;
            padding: 8px 15px;
            font-size: 12px;
            font-weight: bold;
            display: none;
        }
        
        .tab-active {
            border-bottom: 2px solid #00ff99; /* Visual indicator for active tab */
        }

        .triage-banner.warning {
            background: var(--accent-warning);
        }
        
        .triage-banner.error {
            background: var(--accent-error);
            color: #fff;
        }
        
        .terminal-container {
            flex: 1;
            position: relative;
            background: #000;
        }
        
        #terminal {
            width: 100%;
            height: calc(100% - 45px); /* Reserve space for command bar */
            padding: 15px;
            font-size: 14px;
        }
        
        .terminal-command-bar {
            height: 45px;
            display: flex;
            align-items: center;
            padding: 8px 15px;
            border-top: 1px solid var(--border);
            background: var(--bg-secondary);
            gap: 10px;
            /* 🎨 DEBUG: Temporary magenta background for visibility */
            box-shadow: 0 0 3px rgba(255, 0, 255, 0.5);
            border: 2px solid #ff00ff33;
        }
        
        .terminal-command-bar input {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            outline: none;
            transition: all 0.2s;
        }
        
        .terminal-command-bar input:focus {
            border-color: var(--accent-info);
            box-shadow: 0 0 0 2px rgba(116, 192, 252, 0.2);
        }
        
        .terminal-command-bar input.success {
            border-color: var(--accent-success);
            box-shadow: 0 0 8px rgba(81, 207, 102, 0.4);
        }
        
        .terminal-command-bar button {
            background: var(--accent-info);
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            color: #000;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .terminal-command-bar button:hover {
            background: rgba(116, 192, 252, 0.8);
        }
        
        .command-suggestions {
            position: absolute;
            bottom: 50px;
            left: 15px;
            right: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
        }
        
        .command-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .command-suggestion:hover,
        .command-suggestion.selected {
            background: var(--accent-info);
            color: #000;
        }
        
        .telemetry-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px;
            font-size: 11px;
            color: var(--text-secondary);
            display: none;
            z-index: 999;
        }
        
        .init-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .init-content {
            text-align: center;
            padding: 30px;
            max-width: 500px;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top: 3px solid var(--accent-info);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .init-step {
            font-size: 14px;
            margin: 10px 0;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        
        .init-step.pending { color: var(--text-secondary); }
        .init-step.loading { 
            color: var(--accent-info);
            background: rgba(116, 192, 252, 0.1);
        }
        .init-step.success { 
            color: var(--accent-success);
            background: rgba(81, 207, 102, 0.1);
        }
        .init-step.warning { 
            color: var(--accent-warning);
            background: rgba(255, 211, 61, 0.1);
        }
        .init-step.error { 
            color: var(--accent-error);
            background: rgba(255, 107, 107, 0.1);
        }
        
        .fallback-controls {
            margin-top: 20px;
            display: none;
        }
        
        .btn {
            background: var(--accent-info);
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            font-weight: bold;
            margin: 0 5px;
            transition: all 0.2s;
        }
        
        .btn:hover { opacity: 0.8; }
        .btn.success { background: var(--accent-success); }
        .btn.warning { background: var(--accent-warning); }
        .btn.error { background: var(--accent-error); color: #fff; }
        
        .error-details {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-size: 12px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .status-bar {
            height: 30px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-size: 11px;
        }
        
        .status-left, .status-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .status-item {
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .status-item.success { color: var(--accent-success); }
        .status-item.warning { color: var(--accent-warning); }
        .status-item.error { color: var(--accent-error); }
        .status-item.info { color: var(--accent-info); }
        
        .recovery-mode {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
        }
        
        .recovery-mode .triage-banner {
            background: rgba(255, 255, 255, 0.9);
            color: #d63447;
        }
    </style>
</head>
<body id="app-body">
    <div class="title-bar">
        <div class="title-bar-left">
            <div class="app-logo">🚀</div>
            <div class="title-bar-title">RinaWarp Terminal - Robust Edition</div>
        </div>
        
        <div class="system-status">
            <div id="api-status"><span class="status-dot red"></span>APIs</div>
            <div id="xterm-status"><span class="status-dot red"></span>XTerm</div>
            <div id="shell-status"><span class="status-dot red"></span>Shell</div>
            <div id="triage-status"><span class="status-dot blue"></span>Triage</div>
        </div>
        
        <div class="title-bar-controls">
            <button class="title-bar-control" onclick="minimizeWindow()" title="Minimize"></button>
            <button class="title-bar-control" onclick="maximizeWindow()" title="Maximize"></button>
            <button class="title-bar-control" onclick="closeWindow()" title="Close"></button>
        </div>
    </div>
    
    <div id="triage-banner" class="triage-banner">
        <span id="triage-message">Initializing terminal systems...</span>
    </div>
    
    <!-- Tab Bar -->
    <div class="tab-bar" id="tab-bar">
        <div class="tab active" id="tab-main" data-tab-id="main">
            <div class="tab-title">Terminal</div>
            <button class="tab-close" onclick="closeTab('main')" title="Close tab">×</button>
        </div>
        <button class="tab-add" onclick="addNewTab()" title="New tab">+ New</button>
    </div>
    
    <div class="main-container">
        <div class="terminal-container">
            <div id="terminal"></div>
            
            <!-- Initialization Overlay -->
            <div id="init-overlay" class="init-overlay">
                <div class="init-content">
                    <div class="loading-spinner" id="loading-spinner"></div>
                    <h3 id="init-title">🩺 Triage-Informed Terminal Initialization</h3>
                    <div id="init-message">Performing system diagnostics...</div>
                    
                    <div id="init-steps">
                        <div id="step-api" class="init-step pending">📡 Electron API Detection</div>
                        <div id="step-triage" class="init-step pending">🩺 Error Triage System</div>
                        <div id="step-xterm" class="init-step pending">📺 XTerm Module Loading</div>
                        <div id="step-shell" class="init-step pending">🐚 Shell Process Creation</div>
                        <div id="step-integration" class="init-step pending">🔗 System Integration</div>
                    </div>
                    
                    <div class="fallback-controls" id="fallback-controls">
                        <button class="btn success" onclick="enterRecoveryMode()">🛠️ Recovery Mode</button>
                        <button class="btn warning" onclick="retryInitialization()">🔄 Retry</button>
                        <button class="btn error" onclick="showErrorDetails()">📋 Error Details</button>
                    </div>
                    
                    <div class="error-details" id="error-details"></div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-left">
                <div class="status-item" id="platform-info">Platform: Loading...</div>
                <div class="status-item" id="process-info">Process: Not started</div>
                <div class="status-item" id="mode-info">Mode: Initializing</div>
            </div>
            <div class="status-right">
                <div class="status-item info" id="version-info">RinaWarp v1.0.19-robust</div>
                <div class="status-item" id="uptime-info">Uptime: 0s</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let terminal = null;
        let shellProcess = null;
        let triageSystem = null;
        let initializationErrors = [];
        let initStartTime = Date.now();
        let isRecoveryMode = false;
        let uptimeInterval = null;
        
        // Tab management state
        let tabs = new Map();
        let activeTabId = 'main';
        let tabCounter = 1;
        
        // Self-aware addon registry and telemetry
        let addonRegistry = {
            fit: null,
            weblinks: null,
            available: [],
            missing: []
        };
        
        let tabTelemetry = new Map(); // Per-tab health metrics
        
        // Command registry for intelligent routing
        const COMMAND_REGISTRY = {
            'help': { description: 'Show available commands', category: 'system' },
            'status': { description: 'Show system health status', category: 'diagnostic' },
            'triage': { description: 'Show error triage report', category: 'diagnostic' },
            'addons': { description: 'Show addon registry info', category: 'diagnostic' },
            'clear': { description: 'Clear terminal output', category: 'terminal' },
            'glow': { description: 'Activate visual feedback', category: 'ui' },
            'telemetry': { description: 'Show tab telemetry', category: 'diagnostic' },
            'simulate-fault': { description: 'Trigger error for testing', category: 'testing' },
            'voice-test': { description: 'Test voice command system', category: 'testing' }
        };
        
        // CommandBar Manager Class
        class CommandBarManager {
            constructor(tabId, terminalInstance, shellProcess = null) {
                this.tabId = tabId;
                this.terminal = terminalInstance;
                this.shellProcess = shellProcess;
                this.inputId = `cmd-input-${tabId}`;
                this.buttonId = `cmd-run-${tabId}`;
                this.commandHistory = [];
                this.historyIndex = -1;
                this.isInjected = false;
            }
            
            inject() {
                if (this.isInjected) return;
                
                console.log(`🎹 Injecting CommandBar for tab ${this.tabId}`);
                
                const cmdBar = document.createElement('div');
                cmdBar.className = 'terminal-command-bar';
                cmdBar.id = `cmd-bar-${this.tabId}`;
                cmdBar.innerHTML = `
                    <input type="text" id="${this.inputId}" placeholder="Enter command (try 'help')..." autocomplete="off" />
                    <button id="${this.buttonId}" title="Execute command">⚡ Run</button>
                    <div class="command-suggestions" id="suggestions-${this.tabId}"></div>
                `;
                
                // Find the terminal container and append command bar
                let container;
                if (this.tabId === 'main') {
                    container = document.getElementById('terminal').parentNode;
                } else {
                    container = document.getElementById(`terminal-${this.tabId}`).parentNode;
                }
                
                if (container) {
                    container.appendChild(cmdBar);
                    this.bindEvents();
                    this.isInjected = true;
                    console.log(`✅ CommandBar injected for tab ${this.tabId}`);
                } else {
                    console.error(`❌ Could not find container for tab ${this.tabId}`);
                }
            }
            
            bindEvents() {
                const inputEl = document.getElementById(this.inputId);
                const buttonEl = document.getElementById(this.buttonId);
                
                if (!inputEl || !buttonEl) return;
                
                // Button click
                buttonEl.onclick = () => this.executeCommand();
                
                // Enter key and command history
                inputEl.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        this.executeCommand();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.navigateHistory('up');
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.navigateHistory('down');
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        this.showAutocomplete();
                    }
                };
                
                // Live autocomplete suggestions
                inputEl.oninput = () => this.updateSuggestions();
                
                // Focus management
                inputEl.onfocus = () => this.updateSuggestions();
                inputEl.onblur = () => {
                    setTimeout(() => this.hideSuggestions(), 150);
                };
            }
            
            executeCommand() {
                const inputEl = document.getElementById(this.inputId);
                const command = inputEl.value.trim();
                
                if (!command) return;
                
                // Add to history
                this.commandHistory.push(command);
                this.historyIndex = -1;
                
                // Visual feedback
                this.showExecutionFeedback();
                
                // Route command
                this.routeCommand(command);
                
                // Clear input
                inputEl.value = '';
                this.hideSuggestions();
            }
            
            routeCommand(command) {
                const [cmd, ...args] = command.toLowerCase().split(' ');
                
                // Echo command to terminal
                if (this.terminal && this.terminal.writeln) {
                    this.terminal.writeln(`\r\n🎹 Command: ${command}`);
                }
                
                switch (cmd) {
                    case 'help':
                        this.showHelp();
                        break;
                    case 'status':
                        this.showSystemStatus();
                        break;
                    case 'triage':
                        this.showTriageReport();
                        break;
                    case 'addons':
                        this.showAddonRegistry();
                        break;
                    case 'clear':
                        this.clearTerminal();
                        break;
                    case 'glow':
                        this.activateGlow();
                        break;
                    case 'telemetry':
                        this.showTelemetry();
                        break;
                    case 'simulate-fault':
                        this.simulateFault(args[0] || 'test');
                        break;
                    case 'voice-test':
                        this.testVoiceSystem();
                        break;
                    default:
                        // Pass to shell if available, otherwise show unknown command
                        if (this.shellProcess) {
                            this.sendToShell(command);
                        } else {
                            this.showUnknownCommand(command);
                        }
                }
            }
            
            sendToShell(command) {
                if (this.shellProcess && window.electronAPI) {
                    window.electronAPI.writeToShell(this.shellProcess.id, command + '\r\n');
                } else {
                    this.terminal?.writeln('⚠️ No shell process available for this tab');
                }
            }
            
            showHelp() {
                if (!this.terminal?.writeln) return;
                
                this.terminal.writeln('\r\n🧠 RinaWarp CommandBar - Available Commands:');
                this.terminal.writeln('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                
                Object.entries(COMMAND_REGISTRY).forEach(([cmd, info]) => {
                    const categoryIcon = info.category === 'system' ? '⚙️' :
                                         info.category === 'diagnostic' ? '🩺' :
                                         info.category === 'terminal' ? '💻' :
                                         info.category === 'ui' ? '🎨' : '🧪';
                    this.terminal.writeln(`  ${categoryIcon} ${cmd.padEnd(15)} - ${info.description}`);
                });
                
                this.terminal.writeln('\r\n💡 Tips:');
                this.terminal.writeln('  • Use ↑/↓ arrows for command history');
                this.terminal.writeln('  • Use Tab for autocomplete');
                this.terminal.writeln('  • Shell commands work if process is available\r\n');
            }
            
            showSystemStatus() {
                if (!this.terminal?.writeln) return;
                
                const health = triageSystem?.getSystemHealth() || { status: 'unknown', percentage: 0 };
                const uptime = Math.floor((Date.now() - initStartTime) / 1000);
                
                this.terminal.writeln('\r\n📊 System Status Report:');
                this.terminal.writeln('━━━━━━━━━━━━━━━━━━━━━━━━');
                this.terminal.writeln(`🩺 Health: ${health.status.toUpperCase()} (${health.percentage.toFixed(0)}%)`);
                this.terminal.writeln(`⏱️ Uptime: ${uptime}s`);
                this.terminal.writeln(`📑 Active Tabs: ${tabs.size}`);
                this.terminal.writeln(`🔧 Addons Available: ${addonRegistry.available.join(', ') || 'None'}`);
                this.terminal.writeln(`⚠️ Addons Missing: ${addonRegistry.missing.join(', ') || 'None'}`);
                this.terminal.writeln(`🐚 Shell Process: ${this.shellProcess ? `PID ${this.shellProcess.pid}` : 'Not available'}\r\n`);
            }
            
            showAddonRegistry() {
                if (!this.terminal?.writeln) return;
                
                this.terminal.writeln('\r\n🧬 Addon Registry:');
                this.terminal.writeln('━━━━━━━━━━━━━━━━━');
                this.terminal.writeln(`✅ Available: ${addonRegistry.available.join(', ') || 'None'}`);
                this.terminal.writeln(`❌ Missing: ${addonRegistry.missing.join(', ') || 'None'}`);
                this.terminal.writeln(`🔧 FitAddon: ${addonRegistry.fit ? 'Loaded' : 'Not available'}`);
                this.terminal.writeln(`🔗 WebLinksAddon: ${addonRegistry.weblinks ? 'Loaded' : 'Not available'}\r\n`);
            }
            
            showTriageReport() {
                if (!this.terminal?.writeln || !triageSystem) return;
                
                const errors = triageSystem.errors.slice(-5); // Last 5 errors
                this.terminal.writeln('\r\n🩺 Recent Triage Reports:');
                this.terminal.writeln('━━━━━━━━━━━━━━━━━━━━━━━━');
                
                if (errors.length === 0) {
                    this.terminal.writeln('✅ No recent errors - system healthy!');
                } else {
                    errors.forEach((err, i) => {
                        const time = new Date(err.timestamp).toLocaleTimeString();
                        this.terminal.writeln(`${i + 1}. [${time}] ${err.subsystem}: ${err.error}`);
                        this.terminal.writeln(`   Severity: ${err.severity} | Recoverable: ${err.recoverable}`);
                    });
                }
                this.terminal.writeln('');
            }
            
            clearTerminal() {
                if (this.terminal?.clear) {
                    this.terminal.clear();
                } else if (this.terminal?.writeln) {
                    // Fallback clear for simple terminals
                    for (let i = 0; i < 50; i++) {
                        this.terminal.writeln('');
                    }
                }
            }
            
            activateGlow() {
                const inputEl = document.getElementById(this.inputId);
                if (inputEl) {
                    inputEl.style.boxShadow = '0 0 15px #00ff99, 0 0 30px #00ff99';
                    inputEl.style.borderColor = '#00ff99';
                    setTimeout(() => {
                        inputEl.style.boxShadow = '';
                        inputEl.style.borderColor = '';
                    }, 2000);
                }
                this.terminal?.writeln('✨ Glow activated!');
            }
            
            simulateFault(type = 'test') {
                if (triageSystem) {
                    const testError = new Error(`Simulated ${type} fault for testing`);
                    triageSystem.reportError(testError, {
                        subsystem: 'testing',
                        component: 'command-bar',
                        operation: 'simulate-fault',
                        severity: 'low'
                    });
                    this.terminal?.writeln(`🧪 Simulated fault: ${type}`);
                }
            }
            
            testVoiceSystem() {
                this.terminal?.writeln('🎤 Voice system test - feature coming soon!');
            }
            
            showTelemetry() {
                const telemetry = tabTelemetry.get(this.tabId) || {};
                this.terminal?.writeln('\r\n📊 Tab Telemetry:');
                this.terminal?.writeln(`Tab ID: ${this.tabId}`);
                this.terminal?.writeln(`Commands Executed: ${this.commandHistory.length}`);
                this.terminal?.writeln(`Terminal Type: ${this.terminal?._isFallback ? 'Fallback' : 'XTerm'}`);
                this.terminal?.writeln('');
            }
            
            showUnknownCommand(command) {
                this.terminal?.writeln(`❓ Unknown command: '${command}'`);
                this.terminal?.writeln('💡 Type "help" to see available commands\r\n');
            }
            
            showExecutionFeedback() {
                const inputEl = document.getElementById(this.inputId);
                const buttonEl = document.getElementById(this.buttonId);
                
                if (inputEl) {
                    inputEl.classList.add('success');
                    setTimeout(() => inputEl.classList.remove('success'), 300);
                }
                
                if (buttonEl) {
                    buttonEl.style.background = '#00ff99';
                    buttonEl.textContent = '✅';
                    setTimeout(() => {
                        buttonEl.style.background = '';
                        buttonEl.textContent = '⚡ Run';
                    }, 600);
                }
            }
            
            navigateHistory(direction) {
                const inputEl = document.getElementById(this.inputId);
                if (!inputEl || this.commandHistory.length === 0) return;
                
                if (direction === 'up') {
                    this.historyIndex = this.historyIndex === -1 ? 
                        this.commandHistory.length - 1 : 
                        Math.max(0, this.historyIndex - 1);
                } else {
                    this.historyIndex = this.historyIndex === -1 ? 
                        -1 : 
                        Math.min(this.commandHistory.length - 1, this.historyIndex + 1);
                }
                
                inputEl.value = this.historyIndex === -1 ? '' : this.commandHistory[this.historyIndex];
            }
            
            updateSuggestions() {
                const inputEl = document.getElementById(this.inputId);
                const suggestionsEl = document.getElementById(`suggestions-${this.tabId}`);
                
                if (!inputEl || !suggestionsEl) return;
                
                const input = inputEl.value.toLowerCase();
                if (!input) {
                    this.hideSuggestions();
                    return;
                }
                
                const matches = Object.keys(COMMAND_REGISTRY).filter(cmd => 
                    cmd.startsWith(input)
                ).slice(0, 5);
                
                if (matches.length > 0) {
                    suggestionsEl.innerHTML = matches.map(cmd => 
                        `<div class="command-suggestion" onclick="document.getElementById('${this.inputId}').value='${cmd}'; this.parentNode.style.display='none'">
                            ${cmd} - ${COMMAND_REGISTRY[cmd].description}
                        </div>`
                    ).join('');
                    suggestionsEl.style.display = 'block';
                } else {
                    this.hideSuggestions();
                }
            }
            
            showAutocomplete() {
                const inputEl = document.getElementById(this.inputId);
                const input = inputEl.value.toLowerCase();
                
                const matches = Object.keys(COMMAND_REGISTRY).filter(cmd => 
                    cmd.startsWith(input)
                );
                
                if (matches.length === 1) {
                    inputEl.value = matches[0];
                } else if (matches.length > 1) {
                    this.updateSuggestions();
                }
            }
            
            hideSuggestions() {
                const suggestionsEl = document.getElementById(`suggestions-${this.tabId}`);
                if (suggestionsEl) {
                    suggestionsEl.style.display = 'none';
                }
            }
            
            destroy() {
                const cmdBarEl = document.getElementById(`cmd-bar-${this.tabId}`);
                if (cmdBarEl) {
                    cmdBarEl.remove();
                }
                this.isInjected = false;
            }
        }
        
        // Triage categories based on your suggestion
        const TRIAGE_CATEGORIES = {
            F100: 'critical-api-failure',
            F200: 'xterm-loading-failure', 
            F300: 'shell-creation-failure',
            F400: 'integration-failure',
            F500: 'recoverable-degraded-mode'
        };

        // Enhanced error triage system
        class ErrorTriageSystem {
            constructor() {
                this.errors = [];
                this.systemHealth = {
                    api: false,
                    xterm: false, 
                    shell: false,
                    integration: false
                };
            }

            async reportError(error, context) {
                const triageReport = {
                    timestamp: new Date().toISOString(),
                    error: error.message || error.toString(),
                    stack: error.stack,
                    subsystem: context.subsystem,
                    component: context.component,
                    operation: context.operation,
                    severity: this.categorizeSeverity(error, context),
                    category: this.categorizeError(error, context),
                    recoverable: this.isRecoverable(error, context)
                };

                this.errors.push(triageReport);
                console.error('🩺 Triage Report:', triageReport);

                // Report to main process if possible
                try {
                    if (window.electronAPI) {
                        await window.electronAPI['error-triage-report']?.(error, context);
                    }
                } catch (e) {
                    console.warn('Could not report to main process:', e);
                }

                return triageReport;
            }

            categorizeError(error, context) {
                const msg = error.message?.toLowerCase() || '';
                
                if (context.subsystem === 'api' || msg.includes('electronapi')) {
                    return TRIAGE_CATEGORIES.F100;
                }
                if (context.subsystem === 'xterm' || msg.includes('xterm') || msg.includes('terminal')) {
                    return TRIAGE_CATEGORIES.F200;
                }
                if (context.subsystem === 'shell' || context.operation === 'shell-creation') {
                    return TRIAGE_CATEGORIES.F300;
                }
                if (context.subsystem === 'integration') {
                    return TRIAGE_CATEGORIES.F400;
                }
                return TRIAGE_CATEGORIES.F500;
            }

            categorizeSeverity(error, context) {
                const category = this.categorizeError(error, context);
                switch (category) {
                    case TRIAGE_CATEGORIES.F100: return 'critical';
                    case TRIAGE_CATEGORIES.F200: return 'high';
                    case TRIAGE_CATEGORIES.F300: return 'high';
                    case TRIAGE_CATEGORIES.F400: return 'medium';
                    case TRIAGE_CATEGORIES.F500: return 'low';
                    default: return 'medium';
                }
            }

            isRecoverable(error, context) {
                const category = this.categorizeError(error, context);
                return category !== TRIAGE_CATEGORIES.F100; // API failures are typically non-recoverable
            }

            getSystemHealth() {
                const totalSystems = Object.keys(this.systemHealth).length;
                const healthySystems = Object.values(this.systemHealth).filter(h => h).length;
                const healthPercentage = (healthySystems / totalSystems) * 100;
                
                return {
                    percentage: healthPercentage,
                    systems: this.systemHealth,
                    status: healthPercentage === 100 ? 'healthy' : 
                           healthPercentage >= 75 ? 'degraded' :
                           healthPercentage >= 50 ? 'compromised' : 'critical'
                };
            }
        }

        // Window controls
        function minimizeWindow() {
            if (window.electronAPI) {
                window.electronAPI.minimizeWindow?.() || 
                window.electronAPI.ipcRenderer?.send('window-minimize');
            }
        }

        function maximizeWindow() {
            if (window.electronAPI) {
                window.electronAPI.maximizeWindow?.() || 
                window.electronAPI.ipcRenderer?.send('window-maximize');
            }
        }

        function closeWindow() {
            if (window.electronAPI) {
                window.electronAPI.closeWindow?.() || 
                window.electronAPI.ipcRenderer?.send('window-close');
            }
        }

        // UI update functions
        function updateTriageBanner(message, type = 'info') {
            const banner = document.getElementById('triage-banner');
            const messageEl = document.getElementById('triage-message');
            
            banner.className = `triage-banner ${type}`;
            messageEl.textContent = message;
            banner.style.display = 'block';
        }

        function updateSystemStatus(system, status) {
            const statusEl = document.getElementById(`${system}-status`);
            if (statusEl) {
                const dot = statusEl.querySelector('.status-dot');
                dot.className = `status-dot ${status === 'ok' ? 'green' : 
                                               status === 'warning' ? 'yellow' : 
                                               status === 'loading' ? 'blue' : 'red'}`;
            }
            
            if (triageSystem) {
                triageSystem.systemHealth[system] = status === 'ok';
            }
        }

        function updateInitStep(stepId, status, message = '') {
            const step = document.getElementById(stepId);
            if (step) {
                step.className = `init-step ${status}`;
                if (message) {
                    const originalText = step.textContent.split(' - ')[0];
                    step.textContent = `${originalText} - ${message}`;
                }
            }
        }

        // Triage-informed initialization sequence
        async function initializeRobustTerminal() {
            console.log('🩺 Starting triage-informed initialization...');
            
            try {
                // Initialize triage system first
                triageSystem = new ErrorTriageSystem();
                updateSystemStatus('triage', 'ok');
                updateInitStep('step-triage', 'success', 'Active');
                
                // Phase 1: Critical API Detection
                updateInitStep('step-api', 'loading', 'Detecting APIs...');
                await initializeAPIs()
                    .catch(err => triageSystem.reportError(err, { 
                        subsystem: 'api', 
                        operation: 'detection' 
                    }).then(() => { throw err; }));
                
                updateInitStep('step-api', 'success', 'Available');
                updateSystemStatus('api', 'ok');
                
                // Phase 2: XTerm Module Loading with Fallback
                updateInitStep('step-xterm', 'loading', 'Loading modules...');
                await initializeXTerm()
                    .catch(err => triageSystem.reportError(err, { 
                        subsystem: 'xterm', 
                        operation: 'load' 
                    }).then(() => { 
                        updateInitStep('step-xterm', 'warning', 'Fallback mode');
                        updateSystemStatus('xterm', 'warning');
                        return createFallbackTerminal(); 
                    }));
                
                if (!document.getElementById('step-xterm').classList.contains('warning')) {
                    updateInitStep('step-xterm', 'success', 'Loaded');
                    updateSystemStatus('xterm', 'ok');
                }
                
                // Phase 3: Shell Process Creation
                updateInitStep('step-shell', 'loading', 'Creating shell...');
                await initializeShellProcess()
                    .catch(err => triageSystem.reportError(err, { 
                        subsystem: 'shell', 
                        operation: 'creation' 
                    }).then(() => { 
                        updateInitStep('step-shell', 'warning', 'Offline mode');
                        updateSystemStatus('shell', 'warning');
                        return null; 
                    }));
                
                if (!document.getElementById('step-shell').classList.contains('warning')) {
                    updateInitStep('step-shell', 'success', 'Connected');
                    updateSystemStatus('shell', 'ok');
                }
                
                // Phase 4: System Integration
                updateInitStep('step-integration', 'loading', 'Integrating...');
                await finalizeIntegration()
                    .catch(err => triageSystem.reportError(err, { 
                        subsystem: 'integration', 
                        operation: 'finalize' 
                    }).then(() => { 
                        updateInitStep('step-integration', 'warning', 'Partial');
                        updateSystemStatus('integration', 'warning');
                    }));
                
                if (!document.getElementById('step-integration').classList.contains('warning')) {
                    updateInitStep('step-integration', 'success', 'Complete');
                    updateSystemStatus('integration', 'ok');
                }
                
                // Complete initialization
                await completeInitialization();
                
            } catch (error) {
                console.error('🚨 Critical initialization failure:', error);
                await showInitializationFailure(error);
            }
        }

        // Phase 1: API Detection
        async function initializeAPIs() {
            if (typeof window.electronAPI === 'undefined') {
                throw new Error('Electron API not available - preload.cjs not loaded correctly');
            }
            
            // Test basic API functionality
            const pong = await window.electronAPI.ping();
            if (pong !== 'pong') {
                throw new Error('Electron API communication test failed');
            }
            
            console.log('✅ Electron APIs detected and tested');
            return true;
        }

        // Phase 2: Enhanced XTerm Loading with Constructor Validation
        async function initializeXTerm() {
            console.log('🧪 🔮 Booting XTerm with multi-strategy loader and constructor validation...');
            
            // Enhanced validation helper for constructor integrity
            function validateConstructors(modules, strategyName) {
                const { Terminal, FitAddon, WebLinksAddon } = modules;
                
                console.log(`🔍 Validating constructors for ${strategyName}:`);
                console.log(`  Terminal:`, Terminal, `Type: ${typeof Terminal}`);
                console.log(`  FitAddon:`, FitAddon, `Type: ${typeof FitAddon}`);
                console.log(`  WebLinksAddon:`, WebLinksAddon, `Type: ${typeof WebLinksAddon}`);
                
                if (!Terminal || typeof Terminal !== 'function') {
                    throw new Error(`Terminal constructor invalid in ${strategyName}. Type: ${typeof Terminal}`);
                }
                
                // Enhanced constructor validation with safety checks
                function isValidConstructor(fn, name) {
                    try {
                        if (typeof fn !== 'function') return false;
                        
                        // Test minimal instantiation
                        const testInstance = new fn({ cols: 80, rows: 24 });
                        const isValid = testInstance && typeof testInstance === 'object';
                        
                        // For Terminal, check essential methods
                        if (name === 'Terminal' && (!testInstance.open || typeof testInstance.open !== 'function')) {
                            return false;
                        }
                        
                        // Clean up test instance
                        testInstance.dispose?.();
                        return isValid;
                    } catch {
                        return false;
                    }
                }
                
                if (!isValidConstructor(Terminal, 'Terminal')) {
                    throw new Error(`Terminal constructor validation failed in ${strategyName} - not constructable or missing methods`);
                }
                
                console.log(`✅ Terminal constructor validation passed for ${strategyName}`);
                
                // Optional addon validation
                if (FitAddon && !isValidConstructor(FitAddon, 'FitAddon')) {
                    console.warn(`⚠️ FitAddon constructor invalid in ${strategyName}, will skip`);
                    modules.FitAddon = null;
                }
                
                if (WebLinksAddon && !isValidConstructor(WebLinksAddon, 'WebLinksAddon')) {
                    console.warn(`⚠️ WebLinksAddon constructor invalid in ${strategyName}, will skip`);
                    modules.WebLinksAddon = null;
                }
                
                // FitAddon and WebLinksAddon are optional, but if present must be constructors
                if (FitAddon && typeof FitAddon !== 'function') {
                    throw new Error(`FitAddon constructor invalid in ${strategyName}. Type: ${typeof FitAddon}`);
                }
                
                if (WebLinksAddon && typeof WebLinksAddon !== 'function') {
                    throw new Error(`WebLinksAddon constructor invalid in ${strategyName}. Type: ${typeof WebLinksAddon}`);
                }
                
                return true;
            }
            
            const strategies = [
                // Strategy 1: Modern ESM Import Pattern
                async () => {
                    console.log('🧪 Strategy 1: Modern ESM imports...');
                    
                    const xtermModule = await import('@xterm/xterm');
                    const fitModule = await import('@xterm/addon-fit');
                    const webLinksModule = await import('@xterm/addon-web-links');
                    
                    const modules = {
                        Terminal: xtermModule.Terminal ?? xtermModule.default?.Terminal ?? xtermModule.default,
                        FitAddon: fitModule.FitAddon ?? fitModule.default?.FitAddon ?? fitModule.default,
                        WebLinksAddon: webLinksModule.WebLinksAddon ?? webLinksModule.default?.WebLinksAddon ?? webLinksModule.default
                    };
                    
                    validateConstructors(modules, 'ESM');
                    return { ...modules, strategy: 'modern-esm' };
                },
                
                // Strategy 2: Direct Path with Smart Export Detection
                async () => {
                    console.log('🧪 Strategy 2: Direct path with export analysis...');
                    
                    const xtermModule = await import('./node_modules/@xterm/xterm/lib/xterm.js');
                    const fitModule = await import('./node_modules/@xterm/addon-fit/lib/addon-fit.js');
                    const webLinksModule = await import('./node_modules/@xterm/addon-web-links/lib/addon-web-links.js');
                    
                    console.log('🔍 XTerm module exports:', Object.keys(xtermModule));
                    console.log('🔍 FitAddon module exports:', Object.keys(fitModule));
                    
                    // Multiple fallback patterns for different module formats
                    const Terminal = xtermModule.Terminal || xtermModule.default?.Terminal || xtermModule.default || window.Terminal;
                    const FitAddon = fitModule.FitAddon || fitModule.default?.FitAddon || fitModule.default;
                    const WebLinksAddon = webLinksModule.WebLinksAddon || webLinksModule.default?.WebLinksAddon || webLinksModule.default;
                    
                    const modules = { Terminal, FitAddon, WebLinksAddon };
                    validateConstructors(modules, 'direct-path');
                    return { ...modules, strategy: 'direct-path-validated' };
                },
                
                // Strategy 3: CommonJS Compatibility Layer
                async () => {
                    console.log('🧪 Strategy 3: CommonJS compatibility...');
                    
                    // Try accessing as if they were CommonJS modules
                    const xtermModule = await import('./node_modules/@xterm/xterm/lib/xterm.js');
                    
                    // Sometimes modules export as module.exports pattern
                    const Terminal = xtermModule.default || xtermModule.Terminal || xtermModule;
                    
                    if (typeof Terminal === 'object' && Terminal.Terminal) {
                        // Nested export pattern
                        const modules = {
                            Terminal: Terminal.Terminal,
                            FitAddon: Terminal.FitAddon || null,
                            WebLinksAddon: Terminal.WebLinksAddon || null
                        };
                        validateConstructors(modules, 'commonjs');
                        return { ...modules, strategy: 'commonjs-compat' };
                    }
                    
                    throw new Error('CommonJS pattern not detected');
                },
                
                // Strategy 4: Global Window Fallback with Validation
                async () => {
                    console.log('🧪 Strategy 4: Global window objects...');
                    
                    const globalModules = {
                        Terminal: window.Terminal || window.XTerm?.Terminal,
                        FitAddon: window.FitAddon || window.XTerm?.FitAddon,
                        WebLinksAddon: window.WebLinksAddon || window.XTerm?.WebLinksAddon
                    };
                    
                    if (!globalModules.Terminal) {
                        throw new Error('No global Terminal constructor found');
                    }
                    
                    validateConstructors(globalModules, 'global');
                    return { ...globalModules, strategy: 'global-validated' };
                }
            ];
            
            let lastError = null;
            
            // Try each strategy with enhanced error reporting
            for (let i = 0; i < strategies.length; i++) {
                try {
                    const { Terminal, FitAddon, WebLinksAddon, strategy } = await strategies[i]();
                    
                    console.log(`✅ XTerm strategy ${i + 1} succeeded: ${strategy}`);
                    console.log(`🎉 Constructors validated - Terminal: ${typeof Terminal}, FitAddon: ${typeof FitAddon}`);
                    
                    // Create terminal instance with validated constructors
                    terminal = new Terminal({
                        fontFamily: 'Consolas, "Courier New", monospace',
                        fontSize: 14,
                        lineHeight: 1.2,
                        cursorBlink: true,
                        cursorStyle: 'block',
                        theme: {
                            background: '#000000',
                            foreground: '#ffffff',
                            cursor: '#ffffff',
                            cursorAccent: '#000000',
                            selection: '#ffffff33',
                            black: '#2e3436',
                            red: '#cc0000',
                            green: '#4e9a06',
                            yellow: '#c4a000',
                            blue: '#3465a4',
                            magenta: '#75507b',
                            cyan: '#06989a',
                            white: '#d3d7cf',
                            brightBlack: '#555753',
                            brightRed: '#ef2929',
                            brightGreen: '#8ae234',
                            brightYellow: '#fce94f',
                            brightBlue: '#729fcf',
                            brightMagenta: '#ad7fa8',
                            brightCyan: '#34e2e2',
                            brightWhite: '#eeeeec'
                        }
                    });

                    // Load validated addons
                    if (FitAddon) {
                        try {
                            const fitAddon = new FitAddon();
                            terminal.loadAddon(fitAddon);
                            terminal._fitAddon = fitAddon;
                            console.log('✅ FitAddon loaded successfully');
                        } catch (err) {
                            console.warn('⚠️ FitAddon failed to load:', err.message);
                        }
                    }
                    
                    if (WebLinksAddon) {
                        try {
                            const webLinksAddon = new WebLinksAddon();
                            terminal.loadAddon(webLinksAddon);
                            console.log('✅ WebLinksAddon loaded successfully');
                        } catch (err) {
                            console.warn('⚠️ WebLinksAddon failed to load:', err.message);
                        }
                    }

                    // Open terminal
                    terminal.open(document.getElementById('terminal'));
                    
                    // Fit terminal if addon is available
                    if (terminal._fitAddon) {
                        terminal._fitAddon.fit();
                        
                        // Handle window resize
                        window.addEventListener('resize', () => {
                            if (terminal._fitAddon) {
                                terminal._fitAddon.fit();
                            }
                        });
                    }

                    console.log(`🎆 XTerm successfully initialized using ${strategy}!`);
                    
                    // Store validated constructors globally for tab creation
                    window.validatedTerminalConstructors = { Terminal, FitAddon, WebLinksAddon };
                    
                    // Initialize self-aware addon registry
                    addonRegistry = {
                        fit: FitAddon || null,
                        weblinks: WebLinksAddon || null,
                        available: [FitAddon && 'FitAddon', WebLinksAddon && 'WebLinksAddon'].filter(Boolean),
                        missing: [!FitAddon && 'FitAddon', !WebLinksAddon && 'WebLinksAddon'].filter(Boolean)
                    };
                    
                    console.log('✅ Validated constructors stored globally for tab creation');
                    console.log('🧬 Addon Registry Initialized:', addonRegistry);
                    
                    return terminal;
                    
                } catch (error) {
                    console.warn(`❌ Strategy ${i + 1} failed: ${error.message}`);
                    lastError = error;
                    
                    // Enhanced triage reporting
                    if (triageSystem) {
                        await triageSystem.reportError(error, {
                            subsystem: 'xterm',
                            operation: `validation-strategy-${i + 1}`,
                            component: 'constructor-validator',
                            severity: 'high'
                        });
                    }
                    
                    continue;
                }
            }
            
            // All strategies failed - create comprehensive error
            const finalError = new Error(`All ${strategies.length} XTerm strategies failed with constructor validation. Last: ${lastError?.message}`);
            finalError.stack = lastError?.stack;
            throw finalError;
        }

        // XTerm fallback implementation  
        function createFallbackTerminal() {
            const terminalEl = document.getElementById('terminal');
            terminalEl.innerHTML = `
                <div style="padding: 20px; height: 100%; display: flex; flex-direction: column; background: #000;">
                    <div style="color: #ffd93d; margin-bottom: 15px; padding: 10px; border: 1px solid #ffd93d; border-radius: 4px;">
                        ⚠️ <strong>Fallback Terminal Mode</strong><br>
                        XTerm.js could not be loaded. Using simplified terminal interface.
                    </div>
                    <div id="fallback-output" style="flex: 1; overflow-y: auto; margin-bottom: 10px; font-family: monospace; font-size: 14px; line-height: 1.4;"></div>
                    <div style="display: flex; align-items: center; border-top: 1px solid #333; padding-top: 10px;">
                        <span style="color: #51cf66; margin-right: 8px; font-weight: bold;">$</span>
                        <input type="text" id="fallback-input" style="
                            flex: 1;
                            background: transparent; 
                            border: none; 
                            color: #fff; 
                            font-family: monospace; 
                            font-size: 14px; 
                            outline: none; 
                            padding: 5px;
                        " placeholder="Type commands here (fallback mode)..." />
                    </div>
                </div>
            `;
            
            // Create fallback terminal API
            terminal = {
                write: (data) => {
                    const output = document.getElementById('fallback-output');
                    if (output) {
                        output.innerHTML += data.replace(/\n/g, '<br>').replace(/\r/g, '');
                        output.scrollTop = output.scrollHeight;
                    }
                },
                writeln: (data) => {
                    const output = document.getElementById('fallback-output');
                    if (output) {
                        output.innerHTML += data + '<br>';
                        output.scrollTop = output.scrollHeight;
                    }
                },
                onData: (callback) => {
                    const input = document.getElementById('fallback-input');
                    if (input && !input.hasDataHandler) {
                        input.hasDataHandler = true;
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                const command = input.value;
                                input.value = '';
                                // Echo the command back
                                terminal.writeln(`$ ${command}`);
                                // Send to shell with proper line ending
                                callback(command + '\r\n');
                            }
                        });
                    }
                },
                clear: () => {
                    const output = document.getElementById('fallback-output');
                    if (output) output.innerHTML = '';
                }
            };
            
            // Focus input
            setTimeout(() => {
                document.getElementById('fallback-input')?.focus();
            }, 100);
            
            console.log('📺 Fallback terminal created');
            return terminal;
        }

        // Phase 3: Shell Process Creation
        async function initializeShellProcess() {
            if (!window.electronAPI) {
                throw new Error('Cannot create shell process - Electron API not available');
            }

            const systemInfo = await window.electronAPI.getSystemInfo();
            document.getElementById('platform-info').textContent = `Platform: ${systemInfo.platform}`;
            
            const shellConfig = {
                shell: systemInfo.shell,
                shellArgs: systemInfo.platform === 'win32' ? ['-NoLogo', '-NoExit'] : [],
                terminalId: 'robust-terminal',
                platform: systemInfo.platform
            };

            shellProcess = await window.electronAPI.createShellProcess(shellConfig);
            
            if (!shellProcess) {
                throw new Error('Shell process creation returned null');
            }

            document.getElementById('process-info').textContent = `Process: PID ${shellProcess.pid}`;
            document.getElementById('process-info').classList.add('success');

            // Set up shell event listeners
            window.electronAPI.onShellData(shellProcess.id, (data) => {
                const output = data.toString();
                if (terminal && terminal.write) {
                    terminal.write(output);
                }
            });

            window.electronAPI.onShellError(shellProcess.id, (data) => {
                const error = data.toString();
                if (terminal && terminal.write) {
                    terminal.write(`\r\n[STDERR] ${error}\r\n`);
                }
            });

            window.electronAPI.onShellExit(shellProcess.id, (code, signal) => {
                document.getElementById('process-info').textContent = `Process: Exited (${code})`;
                document.getElementById('process-info').classList.remove('success');
                document.getElementById('process-info').classList.add('warning');
                
                if (terminal && terminal.write) {
                    terminal.write(`\r\n[Process exited with code ${code}]\r\n`);
                }
            });

            // Handle terminal input
            if (terminal && terminal.onData) {
                terminal.onData((data) => {
                    window.electronAPI.writeToShell(shellProcess.id, data);
                });
            }

            console.log('✅ Shell process created and connected');
            return shellProcess;
        }

        // Phase 4: System Integration
        async function finalizeIntegration() {
            // Start uptime counter
            uptimeInterval = setInterval(() => {
                const uptime = Math.floor((Date.now() - initStartTime) / 1000);
                document.getElementById('uptime-info').textContent = `Uptime: ${uptime}s`;
            }, 1000);

            // Send welcome message to terminal
            if (terminal) {
                terminal.writeln('');
                terminal.writeln('🚀 RinaWarp Terminal - Robust Edition');
                terminal.writeln('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                terminal.writeln('');
                
                const health = triageSystem.getSystemHealth();
                terminal.writeln(`🩺 System Health: ${health.status.toUpperCase()} (${health.percentage.toFixed(0)}%)`);
                
                if (health.status !== 'healthy') {
                    terminal.writeln(`⚠️  Running in ${health.status} mode - some features may be limited`);
                }
                
                terminal.writeln('');
                terminal.writeln('Type "help" for available commands or start using your terminal normally.');
                terminal.writeln('');
            }

            document.getElementById('mode-info').textContent = `Mode: ${triageSystem.getSystemHealth().status}`;
            document.getElementById('mode-info').classList.add(
                triageSystem.getSystemHealth().status === 'healthy' ? 'success' : 'warning'
            );

            console.log('✅ System integration completed');
        }

        // Complete initialization
        async function completeInitialization() {
            const health = triageSystem.getSystemHealth();
            
            // Update triage banner
            if (health.status === 'healthy') {
                updateTriageBanner('✅ All systems operational - Terminal ready!', 'info');
            } else {
                updateTriageBanner(`⚠️ Running in ${health.status} mode - Terminal functional with limitations`, 'warning');
            }

            // Initialize tab system
            initializeTabSystem();
            
            // Hide initialization overlay
            setTimeout(() => {
                document.getElementById('init-overlay').style.display = 'none';
            }, 1500);

            console.log(`🎉 Robust terminal initialization complete - Status: ${health.status}`);
        }

        // Handle initialization failure
        async function showInitializationFailure(error) {
            updateInitStep('step-integration', 'error', 'Failed');
            
            document.getElementById('init-title').textContent = '🚨 Terminal Initialization Failed';
            document.getElementById('init-message').textContent = 
                'Critical errors prevented normal startup. Recovery options available.';
            
            document.getElementById('loading-spinner').style.display = 'none';
            document.getElementById('fallback-controls').style.display = 'block';
            
            updateTriageBanner('🚨 Critical initialization failure - Recovery mode available', 'error');
            
            initializationErrors.push(error);
            console.error('🚨 Initialization failure:', error);
        }

        // Recovery mode functions
        function enterRecoveryMode() {
            console.log('🛠️ Entering recovery mode...');
            isRecoveryMode = true;
            
            document.getElementById('app-body').classList.add('recovery-mode');
            document.getElementById('init-overlay').style.display = 'none';
            
            updateTriageBanner('🛠️ Recovery Mode Active - Basic terminal functionality only', 'warning');
            
            // Create minimal recovery terminal
            const terminalEl = document.getElementById('terminal');
            terminalEl.innerHTML = `
                <div style="padding: 20px; color: #fff; font-family: monospace;">
                    <div style="color: #ffd93d; font-size: 18px; margin-bottom: 20px;">
                        🛠️ <strong>RECOVERY MODE</strong>
                    </div>
                    <div style="margin-bottom: 15px;">
                        The terminal encountered initialization errors but you can still access basic functionality:
                    </div>
                    <div style="margin: 10px 0; padding: 10px; border: 1px solid #444; border-radius: 4px;">
                        • No shell integration (commands won't execute)<br>
                        • Limited terminal emulation<br>
                        • Basic text interface only<br>
                        • Error reporting available
                    </div>
                    <div style="margin-top: 20px;">
                        <button class="btn warning" onclick="retryInitialization()">🔄 Retry Full Initialization</button>
                        <button class="btn error" onclick="showErrorDetails()">📋 Show Error Report</button>
                    </div>
                    <div style="margin-top: 30px; font-size: 12px; color: #aaa;">
                        Recovery Mode Terminal - Type for basic text input
                    </div>
                    <div style="margin-top: 10px;">
                        <span style="color: #51cf66;">recovery$</span>
                        <input type="text" style="background: transparent; border: none; color: #fff; font-family: monospace; margin-left: 5px; width: 300px;" 
                               placeholder="Basic text input (no command execution)" />
                    </div>
                </div>
            `;
            
            document.getElementById('mode-info').textContent = 'Mode: Recovery';
            document.getElementById('mode-info').classList.add('error');
        }

        function retryInitialization() {
            console.log('🔄 Retrying initialization...');
            location.reload();
        }

        function showErrorDetails() {
            const errorDetails = document.getElementById('error-details');
            const allErrors = [...initializationErrors, ...triageSystem.errors];
            
            errorDetails.innerHTML = `
                <h4>🩺 Error Triage Report</h4>
                <div style="margin-bottom: 10px;">
                    <strong>System Health:</strong> ${triageSystem.getSystemHealth().status}<br>
                    <strong>Total Errors:</strong> ${allErrors.length}<br>
                    <strong>Initialization Time:</strong> ${Date.now() - initStartTime}ms
                </div>
                <div style="max-height: 150px; overflow-y: auto;">
                    ${allErrors.map(err => `
                        <div style="margin: 5px 0; padding: 5px; border: 1px solid #444; border-radius: 2px; font-size: 11px;">
                            <strong>${err.subsystem || 'Unknown'}:</strong> ${err.error || err.message}<br>
                            <span style="color: #aaa;">Category: ${err.category || 'N/A'} | Severity: ${err.severity || 'medium'}</span>
                        </div>
                    `).join('')}
                </div>
            `;
            errorDetails.style.display = 'block';
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🌊 DOM loaded - Starting robust terminal initialization...');
            
            // Small delay to ensure all APIs are ready
            setTimeout(() => {
                initializeRobustTerminal();
            }, 500);
        });

        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            if (triageSystem) {
                triageSystem.reportError(event.error, { 
                    subsystem: 'global', 
                    operation: 'runtime' 
                });
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+R: Reload
            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                retryInitialization();
            }
            
            // Ctrl+Shift+R: Enter recovery mode
            if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                e.preventDefault();
                if (!isRecoveryMode) {
                    enterRecoveryMode();
                }
            }
        });

        // === TAB MANAGEMENT FUNCTIONS ===
        
        // Initialize tab system
        function initializeTabSystem() {
            // Register main tab
            tabs.set('main', {
                id: 'main',
                title: 'Terminal',
                terminal: terminal,
                shellProcess: shellProcess,
                element: document.getElementById('terminal'),
                isMain: true
            });
            
            // 🎯 DEBUG: Inject CommandBar for main tab
            console.log('📦 Injecting CommandBar for main tab');
            console.log('🧪 Terminal instance available:', !!terminal);
            console.log('🧪 Shell process available:', !!shellProcess);
            
            try {
                const mainCommandBar = new CommandBarManager('main', terminal, shellProcess);
                mainCommandBar.inject();
                
                // Store command bar reference
                const mainTab = tabs.get('main');
                if (mainTab) {
                    mainTab.commandBar = mainCommandBar;
                    tabs.set('main', mainTab);
                }
                
                console.log('✅ CommandBar injected for main tab successfully');
            } catch (error) {
                console.error('❌ Failed to inject CommandBar for main tab:', error);
            }
            
            console.log('📑 Tab system initialized');
        }
        
        // Add new tab
        async function addNewTab() {
            try {
            const tabId = `tab-${Date.now()}`;
            const tabTitle = `Terminal ${tabCounter}`;
            tabCounter++;
            
            console.log(`📑 Creating new tab: ${tabId}`);
            
            // Create tab HTML element
            tabs.set(tabId, {
                terminal: null, // placeholder
                commandBar: null, // placeholder
                status: '' // placeholder
            });
                const tabElement = document.createElement('div');
                tabElement.className = 'tab';
                tabElement.id = `tab-${tabId}`;
                tabElement.setAttribute('data-tab-id', tabId);
                tabElement.innerHTML = `
                    <div class="tab-title">${tabTitle}</div>
                    <button class="tab-close" onclick="closeTab('${tabId}')" title="Close tab">×</button>
                `;
                
                // Add click handler for tab switching
                tabElement.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('tab-close')) {
                        switchToTab(tabId);
                    }
                });
                
                // Insert before the add button
                const addButton = document.querySelector('.tab-add');
                addButton.parentNode.insertBefore(tabElement, addButton);
                
                // Create terminal container for this tab
                const terminalContainer = document.createElement('div');
                terminalContainer.id = `terminal-${tabId}`;
                terminalContainer.style.width = '100%';
                terminalContainer.style.height = '100%';
                terminalContainer.style.padding = '15px';
                terminalContainer.style.fontSize = '14px';
                terminalContainer.style.display = 'none'; // Hidden initially
                
                // Add to main terminal container
                document.getElementById('terminal').parentNode.appendChild(terminalContainer);
                
                // Create new terminal instance for this tab
                const newTerminal = await createTerminalInstance(terminalContainer.id);
                const newShellProcess = await createShellProcessForTab(tabId);
                
                // Store tab information
                tabs.set(tabId, {
                    id: tabId,
                    title: tabTitle,
                    terminal: newTerminal,
                    shellProcess: newShellProcess,
                    element: terminalContainer,
                    isMain: false
                });
                
                // 🎯 DEBUG: Inject CommandBar for new tab
                console.log(`📦 Injecting CommandBar for new tab: ${tabId}`);
                console.log('🧪 New terminal instance available:', !!newTerminal);
                console.log('🧪 New shell process available:', !!newShellProcess);
                
                try {
                    const newCommandBar = new CommandBarManager(tabId, newTerminal, newShellProcess);
                    newCommandBar.inject();
                    
                    // Store command bar reference in tab
                    const tabData = tabs.get(tabId);
                    if (tabData) {
                        tabData.commandBar = newCommandBar;
                        tabs.set(tabId, tabData);
                    }
                    
                    console.log(`✅ CommandBar injected for new tab ${tabId} successfully`);
                } catch (error) {
                    console.error(`❌ Failed to inject CommandBar for new tab ${tabId}:`, error);
                }
                
                // Switch to new tab
                switchToTab(tabId);
                
                updateTriageBanner(`📑 New terminal tab created: ${tabTitle}`, 'info');
                setTimeout(() => {
                    if (document.getElementById('triage-banner').textContent.includes('New terminal tab')) {
                        document.getElementById('triage-banner').style.display = 'none';
                    }
                }, 3000);
                
            } catch (error) {
                console.error('Failed to create new tab:', error);
                updateTriageBanner('❌ Failed to create new tab', 'error');
            }
        }
        
        // Enhanced terminal instance creation with robust validation
        async function createTerminalInstance(containerId) {
            const tabId = containerId.replace('terminal-', '');
            console.log(`🧪 Creating terminal instance for container: ${containerId}`);
            
            try {
                // Reuse the validated constructors from the main initialization
                if (!window.validatedTerminalConstructors) {
                    throw new Error('No validated Terminal constructors available - main initialization may have failed');
                }
                
                const { Terminal, FitAddon, WebLinksAddon } = window.validatedTerminalConstructors;
                
                console.log(`🔧 Using validated constructors - Terminal: ${typeof Terminal}, FitAddon: ${typeof FitAddon}`);
                
                // Create terminal with validated constructor
                const newTerminal = new Terminal({
                    fontFamily: 'Consolas, "Courier New", monospace',
                    fontSize: 14,
                    lineHeight: 1.2,
                    cursorBlink: true,
                    cursorStyle: 'block',
                    theme: {
                        background: '#000000',
                        foreground: '#ffffff',
                        cursor: '#ffffff',
                        cursorAccent: '#000000',
                        selection: '#ffffff33',
                        black: '#2e3436',
                        red: '#cc0000',
                        green: '#4e9a06',
                        yellow: '#c4a000',
                        blue: '#3465a4',
                        magenta: '#75507b',
                        cyan: '#06989a',
                        white: '#d3d7cf',
                        brightBlack: '#555753',
                        brightRed: '#ef2929',
                        brightGreen: '#8ae234',
                        brightYellow: '#fce94f',
                        brightBlue: '#729fcf',
                        brightMagenta: '#ad7fa8',
                        brightCyan: '#34e2e2',
                        brightWhite: '#eeeeec'
                    }
                });
                
                // Load addons if available
                if (FitAddon) {
                    try {
                        const fitAddon = new FitAddon();
                        newTerminal.loadAddon(fitAddon);
                        newTerminal._fitAddon = fitAddon;
                        console.log(`✅ FitAddon loaded for ${containerId}`);
                    } catch (fitError) {
                        console.warn(`⚠️ FitAddon failed for ${containerId}:`, fitError.message);
                    }
                }
                
                if (WebLinksAddon) {
                    try {
                        const webLinksAddon = new WebLinksAddon();
                        newTerminal.loadAddon(webLinksAddon);
                        console.log(`✅ WebLinksAddon loaded for ${containerId}`);
                    } catch (linkError) {
                        console.warn(`⚠️ WebLinksAddon failed for ${containerId}:`, linkError.message);
                    }
                }
                
                // Open terminal in container
                const container = document.getElementById(containerId);
                if (!container) {
                    throw new Error(`Container ${containerId} not found in DOM`);
                }
                
                newTerminal.open(container);
                
                // Fit terminal if addon is available
                if (newTerminal._fitAddon) {
                    setTimeout(() => {
                        newTerminal._fitAddon.fit();
                    }, 100);
                }
                
                console.log(`✅ Terminal instance created successfully for ${containerId}`);
                updateTabStatus(tabId, '🟢 Ready');
                return newTerminal;
                
            } catch (error) {
                console.error(`❌ Failed to create terminal instance for ${containerId}:`, error);
                
                // Report to triage system
                if (triageSystem) {
                    await triageSystem.reportError(error, {
                        subsystem: 'terminal',
                        component: 'createTerminalInstance',
                        operation: 'instantiate',
                        tabId: tabId,
                        severity: 'high'
                    });
                }
                
                // Create fallback terminal for this tab
                return createFallbackTerminalForTab(containerId, tabId, error.message);
            }
        }
        
        // Create shell process for tab
        async function createShellProcessForTab(tabId) {
            try {
                const systemInfo = await window.electronAPI.getSystemInfo();
                
                const shellConfig = {
                    shell: systemInfo.shell,
                    shellArgs: systemInfo.platform === 'win32' ? ['-NoLogo', '-NoExit'] : [],
                    terminalId: tabId,
                    platform: systemInfo.platform
                };
                
                const newShellProcess = await window.electronAPI.createShellProcess(shellConfig);
                
                if (newShellProcess) {
                    // Set up event listeners for this shell process
                    const tab = tabs.get(tabId);
                    if (tab && tab.terminal) {
                        window.electronAPI.onShellData(newShellProcess.id, (data) => {
                            const output = data.toString();
                            if (tab.terminal && tab.terminal.write) {
                                tab.terminal.write(output);
                            }
                        });
                        
                        window.electronAPI.onShellError(newShellProcess.id, (data) => {
                            const error = data.toString();
                            if (tab.terminal && tab.terminal.write) {
                                tab.terminal.write(`\r\n[STDERR] ${error}\r\n`);
                            }
                        });
                        
                        window.electronAPI.onShellExit(newShellProcess.id, (code, signal) => {
                            if (tab.terminal && tab.terminal.write) {
                                tab.terminal.write(`\r\n[Process exited with code ${code}]\r\n`);
                            }
                        });
                        
                        // Handle terminal input
                        tab.terminal.onData((data) => {
                            window.electronAPI.writeToShell(newShellProcess.id, data);
                        });
                    }
                }
                
                return newShellProcess;
            } catch (error) {
                console.error('Failed to create shell process for tab:', error);
                return null;
            }
        }
        
        // Switch to tab
        function switchToTab(tabId) {
            console.log(`🔄 DEBUG: Switching to tab ${tabId}`);
            console.log('🔍 Available tabs in registry:', Object.keys(Object.fromEntries(tabs)));
            console.log('🔍 Current active tab before switch:', activeTabId);
            
            // 🛠️ FORCE blur any focused inputs to prevent focus traps
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                console.log('🔧 Blurring active input:', activeElement.id);
                activeElement.blur();
            }
            
            // Update active tab ID
            const previousTab = activeTabId;
            activeTabId = tabId;
            
            // Update tab visual states
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('tab-active');
            });
            
            const activeTab = document.querySelector(`[data-tab-id="${tabId}"]`);
            if (activeTab) {
                activeTab.classList.add('tab-active');
                console.log(`✅ Tab element found and activated: ${tabId}`);
            } else {
                console.error(`❌ Tab element not found for: ${tabId}`);
            }
            
            // Hide all terminal containers AND command bars
            document.querySelectorAll('[id^="terminal"]').forEach(container => {
                container.style.display = 'none';
            });
            document.querySelectorAll('[id^="cmd-bar-"]').forEach(cmdBar => {
                cmdBar.style.display = 'none';
            });
            
            // Show active terminal and command bar
            const tab = tabs.get(tabId);
            if (tab && tab.element) {
                // Handle special case for main tab
                if (tabId === 'main') {
                    document.getElementById('terminal').style.display = 'block';
                } else {
                    tab.element.style.display = 'block';
                }
                
                // Show command bar and focus input
                const cmdBar = document.getElementById(`cmd-bar-${tabId}`);
                if (cmdBar) {
                    cmdBar.style.display = 'flex';
                    console.log(`✅ Command bar shown for tab: ${tabId}`);
                    
                    // Focus the input after a short delay
                    setTimeout(() => {
                        const input = cmdBar.querySelector('input');
                        if (input) input.focus();
                    }, 100);
                } else {
                    console.warn(`⚠️ Command bar not found for tab: ${tabId}`);
                }

                // Resize terminal if it has a fit addon
                if (tab.terminal && tab.terminal._fitAddon) {
                    setTimeout(() => {
                        tab.terminal._fitAddon.fit();
                    }, 100);
                }

                console.log(`✅ Terminal container shown for tab: ${tabId}`);
            } else {
                console.error(`❌ Tab data not found in registry for: ${tabId}`);
            }

            // Update title bar
            const titleElement = document.querySelector('.title-bar-title');
            if (titleElement && tab) {
                titleElement.textContent = `RinaWarp Terminal - ${tab.title}`;
            }

            console.log(`📑 ✅ Successfully switched to tab: ${tabId}`);
        }
        
        // Close tab
        function closeTab(tabId) {
            if (tabId === 'main') {
                // Don't allow closing the main tab
                updateTriageBanner('❌ Cannot close the main terminal tab', 'warning');
                setTimeout(() => {
                    if (document.getElementById('triage-banner').textContent.includes('Cannot close')) {
                        document.getElementById('triage-banner').style.display = 'none';
                    }
                }, 3000);
                return;
            }
            
            const tab = tabs.get(tabId);
            if (!tab) return;
            
            // Kill shell process
            if (tab.shellProcess) {
                window.electronAPI.killShellProcess(tab.shellProcess.id);
            }
            
            // Remove terminal container
            if (tab.element) {
                tab.element.remove();
            }
            
            // Remove tab element
            const tabElement = document.querySelector(`[data-tab-id="${tabId}"]`);
            if (tabElement) {
                tabElement.remove();
            }
            
            // Remove from tabs map
            tabs.delete(tabId);
            
            // Switch to main tab if this was the active tab
            if (activeTabId === tabId) {
                switchToTab('main');
            }
            
            console.log(`📑 Closed tab: ${tabId}`);
            updateTriageBanner(`📑 Terminal tab closed`, 'info');
            setTimeout(() => {
                if (document.getElementById('triage-banner').textContent.includes('tab closed')) {
                    document.getElementById('triage-banner').style.display = 'none';
                }
            }, 2000);
        }
        
        // Tab status management
        function updateTabStatus(tabId, statusLabel) {
            const tab = document.getElementById(`tab-${tabId}`);
            if (tab) {
                tab.setAttribute('data-status', statusLabel);
                tab.title = `Status: ${statusLabel}`;
                
                // Update tab styling based on status
                switch (statusLabel) {
                    case '🟢 Ready':
                        tab.style.borderColor = '#00FF99';
                        tab.style.opacity = '1';
                        break;
                    case '🟡 Fallback':
                        tab.style.borderColor = '#FFCC00';
                        tab.style.opacity = '0.8';
                        break;
                    case '🔴 Error':
                        tab.style.borderColor = '#FF4F4F';
                        tab.style.opacity = '0.6';
                        break;
                }
            }
        }
        
        // Create fallback terminal for specific tab
        function createFallbackTerminalForTab(containerId, tabId, errorMessage) {
            console.log(`📺 Creating fallback terminal for tab ${tabId}`);
            
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container ${containerId} not found for fallback terminal`);
                return null;
            }
            
            container.innerHTML = `
                <div style="padding: 20px; height: 100%; display: flex; flex-direction: column; background: #000;">
                    <div style="color: #ffd93d; margin-bottom: 15px; padding: 10px; border: 1px solid #ffd93d; border-radius: 4px;">
                        ⚠️ <strong>Tab Fallback Mode</strong><br>
                        Terminal initialization failed: ${errorMessage}<br>
                        Using simplified terminal interface for this tab.
                    </div>
                    <div id="fallback-output-${tabId}" style="flex: 1; overflow-y: auto; margin-bottom: 10px; font-family: monospace; font-size: 14px; line-height: 1.4; color: #fff;"></div>
                    <div style="display: flex; align-items: center; border-top: 1px solid #333; padding-top: 10px;">
                        <span style="color: #51cf66; margin-right: 8px; font-weight: bold;">$</span>
                        <input type="text" id="fallback-input-${tabId}" style="
                            flex: 1;
                            background: transparent; 
                            border: none; 
                            color: #fff; 
                            font-family: monospace; 
                            font-size: 14px; 
                            outline: none; 
                            padding: 5px;
                        " placeholder="Type commands here (fallback mode)..." />
                    </div>
                </div>
            `;
            
            // Create fallback terminal API for this specific tab
            const fallbackTerminal = {
                write: (data) => {
                    const output = document.getElementById(`fallback-output-${tabId}`);
                    if (output) {
                        output.innerHTML += data.replace(/\n/g, '<br>').replace(/\r/g, '');
                        output.scrollTop = output.scrollHeight;
                    }
                },
                writeln: (data) => {
                    const output = document.getElementById(`fallback-output-${tabId}`);
                    if (output) {
                        output.innerHTML += data + '<br>';
                        output.scrollTop = output.scrollHeight;
                    }
                },
                onData: (callback) => {
                    const input = document.getElementById(`fallback-input-${tabId}`);
                    if (input && !input.hasDataHandler) {
                        input.hasDataHandler = true;
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                const command = input.value;
                                input.value = '';
                                // Echo the command back
                                fallbackTerminal.writeln(`$ ${command}`);
                                // Send to shell with proper line ending
                                callback(command + '\r\n');
                            }
                        });
                    }
                },
                clear: () => {
                    const output = document.getElementById(`fallback-output-${tabId}`);
                    if (output) output.innerHTML = '';
                },
                _isFallback: true
            };
            
            // Focus input after a short delay
            setTimeout(() => {
                document.getElementById(`fallback-input-${tabId}`)?.focus();
            }, 100);
            
            // Update tab status to show degraded mode
            updateTabStatus(tabId, '🟡 Fallback');
            
            console.log(`📺 Fallback terminal created for tab ${tabId}`);
            return fallbackTerminal;
        }
        
        // Add keyboard shortcuts for tab management
        document.addEventListener('keydown', (e) => {
            // Existing shortcuts...
            
            // Ctrl+T: New tab
            if (e.ctrlKey && e.key === 't') {
                e.preventDefault();
                addNewTab();
            }
            
            // Ctrl+W: Close current tab
            if (e.ctrlKey && e.key === 'w') {
                e.preventDefault();
                closeTab(activeTabId);
            }
            
            // Ctrl+Tab: Next tab
            if (e.ctrlKey && e.key === 'Tab') {
                e.preventDefault();
                const tabIds = Array.from(tabs.keys());
                const currentIndex = tabIds.indexOf(activeTabId);
                const nextIndex = (currentIndex + 1) % tabIds.length;
                switchToTab(tabIds[nextIndex]);
            }
            
            // Ctrl+Shift+Tab: Previous tab
            if (e.ctrlKey && e.shiftKey && e.key === 'Tab') {
                e.preventDefault();
                const tabIds = Array.from(tabs.keys());
                const currentIndex = tabIds.indexOf(activeTabId);
                const prevIndex = currentIndex === 0 ? tabIds.length - 1 : currentIndex - 1;
                switchToTab(tabIds[prevIndex]);
            }
            
            // Ctrl+1-9: Switch to specific tab
            if (e.ctrlKey && e.key >= '1' && e.key <= '9') {
                e.preventDefault();
                const tabIndex = parseInt(e.key) - 1;
                const tabIds = Array.from(tabs.keys());
                if (tabIds[tabIndex]) {
                    switchToTab(tabIds[tabIndex]);
                }
            }
        });
        
        // === DEBUGGING FUNCTIONS ===
        
        // Manual debugging function to examine tab and command bar states
        function debugTabSystem() {
            console.log('\n=== 🔧 TAB SYSTEM DEBUG REPORT ===');
            console.log('🔍 Current Active Tab ID:', activeTabId);
            console.log('🔍 Total Tabs Registered:', tabs.size);
            console.log('🔍 Available Tab IDs:', Array.from(tabs.keys()));
            
            tabs.forEach((tab, tabId) => {
                console.log(`\n📑 Tab ${tabId}:`);
                console.log('  - Title:', tab.title);
                console.log('  - Terminal instance:', !!tab.terminal);
                console.log('  - Shell process:', !!tab.shellProcess);
                console.log('  - DOM element:', !!tab.element);
                console.log('  - Element ID:', tab.element?.id);
                console.log('  - Command bar:', !!tab.commandBar);
                console.log('  - CommandBar injected:', tab.commandBar?.isInjected);
                
                // Check DOM elements
                const tabElement = document.querySelector(`[data-tab-id="${tabId}"]`);
                console.log('  - Tab DOM element found:', !!tabElement);
                console.log('  - Tab element classes:', tabElement?.className);
                
                const cmdBarElement = document.getElementById(`cmd-bar-${tabId}`);
                console.log('  - Command bar DOM element found:', !!cmdBarElement);
                console.log('  - Command bar visible:', cmdBarElement?.style.display !== 'none');
                
                const inputElement = document.getElementById(`cmd-input-${tabId}`);
                console.log('  - Input element found:', !!inputElement);
                console.log('  - Input element focused:', document.activeElement === inputElement);
            });
            
            // Check for any orphaned command bars
            const allCmdBars = document.querySelectorAll('[id^="cmd-bar-"]');
            console.log('\n🔍 All Command Bar Elements in DOM:', allCmdBars.length);
            allCmdBars.forEach(bar => {
                console.log('  - ID:', bar.id, 'Display:', bar.style.display, 'Parent:', bar.parentNode?.id);
            });
            
            console.log('\n=== END DEBUG REPORT ===\n');
        }
        
        // Force tab switch with debugging
        function debugSwitchToTab(tabId) {
            console.log(`\n🛠️ DEBUG: Force switching to tab ${tabId} with full logging`);
            debugTabSystem();
            switchToTab(tabId);
            setTimeout(() => {
                console.log('\n🛠️ POST-SWITCH DEBUG:');
                debugTabSystem();
            }, 500);
        }
        
        // Manual command bar injection debug
        function debugInjectCommandBar(tabId) {
            console.log(`\n🎹 DEBUG: Manual CommandBar injection for tab ${tabId}`);
            const tab = tabs.get(tabId);
            
            if (!tab) {
                console.error(`❌ Tab ${tabId} not found in registry`);
                return;
            }
            
            if (tab.commandBar && tab.commandBar.isInjected) {
                console.log('⚠️ CommandBar already injected, destroying first');
                tab.commandBar.destroy();
            }
            
            try {
                const newCommandBar = new CommandBarManager(tabId, tab.terminal, tab.shellProcess);
                newCommandBar.inject();
                
                tab.commandBar = newCommandBar;
                tabs.set(tabId, tab);
                
                console.log(`✅ CommandBar manually injected for ${tabId}`);
                debugTabSystem();
            } catch (error) {
                console.error(`❌ Manual injection failed:`, error);
            }
        }
        
        // Global accessibility for debugging
        window.debugTabSystem = debugTabSystem;
        window.debugSwitchToTab = debugSwitchToTab;
        window.debugInjectCommandBar = debugInjectCommandBar;
        window.tabsRegistry = tabs;  // For manual inspection
        
        console.log('🩺 Robust terminal system loaded and ready');
        console.log('💡 Debug commands available: debugTabSystem(), debugSwitchToTab(tabId), debugInjectCommandBar(tabId)');
    </script>
</body>
</html>
