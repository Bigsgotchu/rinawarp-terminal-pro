<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <!-- CSP Updated 2025-07-12 for enhanced security -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; connect-src 'self' ws: wss: https://api.elevenlabs.io wss://api.elevenlabs.io; media-src 'self' blob:">
    <title>RinaWarp Terminal - AI-Powered Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #008B8B 0%, #FF1493 50%, #00AAFF 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
            position: relative;
            padding: 20px;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 20, 147, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 139, 139, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(0, 170, 255, 0.15) 0%, transparent 50%);
            animation: waveRipple 20s ease-in-out infinite;
            z-index: -1;
        }
        
        .header {
            background: rgba(0, 139, 139, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 20, 147, 0.3);
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="%23FF1493" opacity="0.05"/><circle cx="80" cy="80" r="3" fill="%23008B8B" opacity="0.05"/><circle cx="50" cy="30" r="1.5" fill="%2300AAFF" opacity="0.05"/></svg>') repeat;
            animation: particleFloat 30s linear infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        .header h1 {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #FF1493, #00AAFF, #8A2BE2, #FF1493);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: logoWave 8s ease-in-out infinite;
        }
        
        .header-logo {
            width: 80px;
            height: 80px;
            display: block;
            margin: 0 auto 20px;
            filter: drop-shadow(0 4px 8px rgba(255, 20, 147, 0.3));
            animation: pulse 2s ease-in-out infinite;
        }
        
        .status {
            margin: 10px 0;
            padding: 15px;
            background: rgba(255, 20, 147, 0.1);
            border: 1px solid rgba(255, 20, 147, 0.3);
            border-radius: 15px;
            text-align: center;
            color: #FF1493;
            text-shadow: 0 0 10px rgba(255, 20, 147, 0.5);
            font-weight: bold;
        }
        
        /* Clean Main Layout */
        .main-layout {
            display: flex;
            height: calc(100vh - 200px);
            margin-top: 20px;
            gap: 20px;
        }
        
        /* Collapsible Sidebar */
        .features-sidebar {
            width: 300px;
            background: rgba(0, 139, 139, 0.2);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 20, 147, 0.3);
            border-radius: 20px;
            padding: 20px;
            transition: all 0.3s ease;
            overflow-y: auto;
            position: relative;
        }
        
        .features-sidebar.collapsed {
            width: 60px;
            padding: 20px 10px;
        }
        
        .sidebar-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(45deg, #FF1493, #00AAFF);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .sidebar-toggle:hover {
            transform: scale(1.1);
        }
        
        .sidebar-content {
            margin-top: 40px;
            transition: opacity 0.3s ease;
        }
        
        .features-sidebar.collapsed .sidebar-content {
            opacity: 0;
            pointer-events: none;
        }
        
        .sidebar-title {
            color: #FF1493;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .feature-group {
            margin-bottom: 20px;
        }
        
        .feature-group-title {
            color: #00AAFF;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .feature-button {
            display: block;
            width: 100%;
            background: rgba(255, 20, 147, 0.1);
            border: 1px solid rgba(255, 20, 147, 0.3);
            color: #FF1493;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            text-align: left;
        }
        
        .feature-button:hover {
            background: rgba(255, 20, 147, 0.2);
            border-color: rgba(255, 20, 147, 0.6);
            transform: translateX(5px);
        }
        
        .feature-button.active {
            background: rgba(255, 20, 147, 0.3);
            border-color: #FF1493;
        }
        
        /* Main Terminal Area */
        .terminal-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .terminal-header-clean {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 139, 139, 0.2);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 20, 147, 0.3);
            border-bottom: none;
            border-radius: 20px 20px 0 0;
            padding: 15px 20px;
        }
        
        .terminal-title {
            color: #FF1493;
            font-size: 16px;
            font-weight: bold;
        }
        
        .terminal-controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(0, 170, 255, 0.1);
            border: 1px solid rgba(0, 170, 255, 0.3);
            color: #00AAFF;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(0, 170, 255, 0.2);
            border-color: #00AAFF;
        }
        
        .terminal-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 170, 255, 0.3);
            border-top: none;
            border-radius: 0 0 20px 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 30px rgba(0, 170, 255, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        #terminal {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(45deg, #FF1493, #00AAFF, #8A2BE2);
            background-size: 200% 200%;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: pearlShimmer 4s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: underwaterCurrent 3s ease-in-out infinite;
        }
        
        button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 20, 147, 0.5);
        }
        
        .ai-section {
            background: rgba(0, 139, 139, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 20, 147, 0.3);
            margin: 30px 0;
            padding: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .ai-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="%23FF1493" opacity="0.05"/><circle cx="80" cy="80" r="3" fill="%23008B8B" opacity="0.05"/><circle cx="50" cy="30" r="1.5" fill="%2300AAFF" opacity="0.05"/></svg>') repeat;
            animation: particleFloat 30s linear infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        input[type="text"] {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 2px solid rgba(255, 20, 147, 0.3);
            padding: 15px;
            margin: 10px 5px 10px 0;
            border-radius: 15px;
            width: 400px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #FF1493;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.5);
            transform: scale(1.02);
        }
        
        .voice-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #ff4444;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 1s infinite;
        }
        
        .voice-indicator.active {
            background: #00ff88;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .feature-card {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #555;
            text-align: center;
        }
        
        .version-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #888;
        }
        
        /* Mermaid Animations */
        @keyframes waveRipple {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
        }
        
        @keyframes logoWave {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes pearlShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes underwaterCurrent {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        @keyframes particleFloat {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
            100% { transform: translateY(0px) rotate(360deg); }
        }
        
        /* Organized interface styles */
        .main-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0 10px;
        }
        
        .advanced-controls {
            background: rgba(0, 139, 139, 0.15);
            border-radius: 15px;
            margin: 10px 0 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 20, 147, 0.2);
            transition: all 0.3s ease;
        }
        
        .controls-section {
            margin-bottom: 20px;
        }
        
        .controls-section:last-child {
            margin-bottom: 0;
        }
        
        .controls-section h4 {
            color: #FF1493;
            margin: 0 0 10px 0;
            font-size: 14px;
            text-align: center;
            background: rgba(255, 20, 147, 0.1);
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 20, 147, 0.3);
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .controls-row button {
            padding: 8px 16px;
            font-size: 13px;
            background: linear-gradient(45deg, #00AAFF, #8A2BE2, #FF1493);
        }
        
        /* Performance mode - disable animations */
        body.performance-mode * {
            animation: none !important;
            transition: none !important;
        }
        
        body.performance-mode .header::before,
        body.performance-mode .ai-section::before {
            display: none;
        }
        
        /* AI Chat Overlay Styles */
        .ai-chat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .ai-chat-container {
            width: 90%;
            max-width: 600px;
            height: 70%;
            background: rgba(0, 139, 139, 0.2);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 20, 147, 0.3);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 170, 255, 0.3);
        }
        
        .ai-chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            background: rgba(255, 20, 147, 0.1);
            border-bottom: 1px solid rgba(255, 20, 147, 0.3);
        }
        
        .ai-chat-title {
            color: #FF1493;
            font-size: 18px;
            font-weight: bold;
        }
        
        .ai-chat-close {
            background: transparent;
            border: 1px solid rgba(255, 20, 147, 0.5);
            color: #FF1493;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .ai-chat-close:hover {
            background: rgba(255, 20, 147, 0.2);
            transform: scale(1.1);
        }
        
        .ai-chat-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        
        .ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(0, 170, 255, 0.3);
        }
        
        .ai-message {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 20, 147, 0.1);
            border-radius: 8px;
            color: #FF1493;
        }
        
        .user-message {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 170, 255, 0.1);
            border-radius: 8px;
            color: #00AAFF;
            text-align: right;
        }
        
        .ai-chat-input {
            display: flex;
            gap: 10px;
        }
        
        .ai-chat-input input {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 170, 255, 0.3);
            color: white;
            padding: 12px;
            border-radius: 10px;
            font-size: 14px;
        }
        
        .ai-chat-input button {
            padding: 12px 20px;
            background: linear-gradient(45deg, #FF1493, #00AAFF);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .ai-chat-input button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.3);
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="../assets/logo-designs/rinawarp-icon-final.svg" alt="RinaWarp Terminal logo - stylized mermaid silhouette in gradient colors representing AI-powered terminal interface" class="header-logo">
        <h1>üöÄ RinaWarp Terminal - AI-Powered Terminal</h1>
        <div class="status" id="status">Initializing AI-powered terminal...</div>
    </div>
    
    <!-- Main Controls -->
    <div class="main-controls">
        <button onclick="runCommand()">‚ö° Quick Command</button>
        <button onclick="clearTerminal()">üóëÔ∏è Clear</button>
        <button onclick="toggleAdvancedControls()" id="advancedToggle">üîß Advanced Tools</button>
    </div>
    
    <!-- Advanced Controls (Initially Hidden) -->
    <div class="advanced-controls" id="advancedControls" style="display: none;">
        <div class="controls-section">
            <h4>ü§ñ AI Features</h4>
            <div class="controls-row">
                <button onclick="startNaturalLanguageAgent()" id="agentModeBtn">ü§ñ AI Agent</button>
                <button onclick="startVoiceControl()" id="voiceControlBtn">üé§ Voice Control <span class="voice-indicator" id="voiceIndicator"></span></button>
                <button onclick="showAIHelp()">üí° AI Help</button>
            </div>
        </div>
        
        <div class="controls-section">
            <h4>‚öôÔ∏è Configuration</h4>
            <div class="controls-row">
                <button onclick="window.settingsPanel && window.settingsPanel.toggle()" class="settings-btn">‚öôÔ∏è Settings</button>
                <button onclick="showAIConfiguration()">üß† AI Config</button>
                <button onclick="configureElevenLabs()">üé§ ElevenLabs</button>
            </div>
        </div>
        
        <div class="controls-section">
            <h4>üöÄ Features</h4>
            <div class="controls-row">
                <button onclick="showFeatures()">‚ú® Features</button>
                <button onclick="startConversationalAI()">üó£Ô∏è Conversational AI</button>
                <button onclick="toggleVoiceOutput()">üîä Voice Output</button>
            </div>
        </div>
    </div>
    
    <!-- Main Layout with Collapsible Sidebar -->
    <div class="main-layout">
        <!-- Collapsible Features Sidebar -->
        <div class="features-sidebar" id="featuresSidebar">
            <button class="sidebar-toggle" onclick="toggleSidebar()">‚Üê</button>
            
            <div class="sidebar-content">
                <div class="sidebar-title">üõ†Ô∏è Features</div>
                
                <!-- AI Features -->
                <div class="feature-group">
                    <div class="feature-group-title">üß† AI Assistant</div>
                    <button class="feature-button active" onclick="showAIChat()">üí¨ AI Chat</button>
                    <button class="feature-button" onclick="startCodeGeneration()">‚ö° Code Generation</button>
                    <button class="feature-button" onclick="startDebugging()">üîß Smart Debug</button>
                    <button class="feature-button" onclick="startArchAnalysis()">üèóÔ∏è Architecture</button>
                </div>
                
                <!-- Voice & Control -->
                <div class="feature-group">
                    <div class="feature-group-title">üé§ Voice & Control</div>
                    <button class="feature-button" onclick="startVoiceControl()">üé§ Voice Control</button>
                    <button class="feature-button" onclick="enableVoiceOutput()">üîä Voice Output</button>
                    <button class="feature-button" onclick="customizeVoice()">üé≠ Voice Settings</button>
                </div>
                
                <!-- Cloud & Sync -->
                <div class="feature-group">
                    <div class="feature-group-title">‚òÅÔ∏è Cloud & Sync</div>
                    <button class="feature-button" onclick="openCloudSync()">‚òÅÔ∏è Cloud Sync</button>
                    <button class="feature-button" onclick="manageBackups()">üíæ Backups</button>
                    <button class="feature-button" onclick="shareSession()">üîó Share Session</button>
                </div>
                
                <!-- Team & Security -->
                <div class="feature-group">
                    <div class="feature-group-title">üë• Team & Security</div>
                    <button class="feature-button" onclick="startCollaboration()">ü§ù Collaboration</button>
                    <button class="feature-button" onclick="openSecurityPanel()">üîí Security</button>
                    <button class="feature-button" onclick="managePermissions()">üõ°Ô∏è Permissions</button>
                </div>
                
                <!-- Advanced -->
                <div class="feature-group">
                    <div class="feature-group-title">‚öôÔ∏è Advanced</div>
                    <button class="feature-button" onclick="showAIConfig()">üß† AI Config</button>
                    <button class="feature-button" onclick="configureElevenLabs()">üé§ ElevenLabs</button>
                    <button class="feature-button" onclick="showFeatures()">‚ú® All Features</button>
                </div>
            </div>
        </div>
        
        <!-- Main Terminal Area -->
        <div class="terminal-area">
            <div class="terminal-header-clean">
                <div class="terminal-title">üßú‚Äç‚ôÄÔ∏è Rina Terminal - AI Powered</div>
                <div class="terminal-controls">
                    <button class="control-btn" onclick="clearTerminal()">üóëÔ∏è Clear</button>
                    <button class="control-btn" onclick="runCommand()">‚ö° Run</button>
                    <button class="control-btn" onclick="showAIChat()">üí¨ AI</button>
                </div>
            </div>
            
            <div class="terminal-container">
                <div id="terminal"></div>
            </div>
        </div>
    </div>
    
    <!-- AI Chat Overlay (Initially Hidden) -->
    <div class="ai-chat-overlay" id="aiChatOverlay" style="display: none;">
        <div class="ai-chat-container">
            <div class="ai-chat-header">
                <div class="ai-chat-title">üßú‚Äç‚ôÄÔ∏è Rina - AI Assistant</div>
                <button class="ai-chat-close" onclick="hideAIChat()">‚úï</button>
            </div>
            
            <div class="ai-chat-content">
                <div class="ai-chat-messages" id="aiChatMessages">
                    <div class="ai-message">
                        üßú‚Äç‚ôÄÔ∏è <em>*emerges from digital depths*</em> Hello! I'm Rina, your AI terminal assistant. Ask me anything!
                    </div>
                </div>
                
                <div class="ai-chat-input">
                    <input type="text" id="aiChatInput" placeholder="Ask Rina anything... (e.g., 'list files')" />
                    <button onclick="sendAIMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="version-info">
        RinaWarp Terminal v1.0.7 - AI Edition
    </div>

    <!-- Load xterm.js and addons from working public vendor directory -->
    <script src="../public/vendor/xterm/xterm.js"></script>
    <script src="utilities/addon-fit.js"></script>
    
    <!-- Script deduplication system -->
    <script type="module" src="script-loader.js"></script>
    
    <!-- Error suppression for known harmless warnings -->
    <script type="module" src="error-suppression.js"></script>
    
    <!-- Terminal wrapper that works without nodeIntegration -->
    <script src="renderer/terminal-wrapper.js"></script>
    
    <!-- Shell harness for graceful command fallback -->
    <script type="module" src="renderer/shell-harness.js"></script>
    
    <!-- Terminal Initialization System -->
    <script type="module" src="renderer/terminal-initialization-system.js"></script>
    
    <!-- Settings Panel -->
    <script type="module" src="renderer/settings-panel.js"></script>
    
    <!-- New Terminal Features -->
    <script type="module" src="renderer/autocomplete-system.js"></script>
    <script type="module" src="renderer/syntax-highlighter.js"></script>
    <script type="module" src="renderer/cloud-sync.js"></script>
    <script type="module" src="renderer/terminal-themes.js"></script>
    <script type="module" src="renderer/command-history.js"></script>
    <script type="module" src="renderer/plugin-system.js"></script>
    <script type="module" src="renderer/split-pane.js"></script>
    <script type="module" src="renderer/error-handler.js"></script>
    
    <!-- Sentry Error Monitoring and User Feedback -->
    <!-- Temporarily disabled due to module resolution issues
    <script type="module">
        import './renderer/sentry-renderer.js';
        // Sentry is now initialized with User Feedback widget
    </script>
    -->
    
    <script src="voice-recognition-advanced.js"></script>
    <script src="rina-personality-engine.js"></script>
    <script src="rina-dialogue-system.js"></script>
    <script src="agents/elevenlabs-agent-integration.js"></script>
    <script type="module" src="ai-services/llm-api-client.js"></script>
    <script type="module" src="ai-services/advanced-learning-engine.js"></script>
    <script type="module" src="ai-services/unified-ai-system.js"></script>
    
    <!-- Enhanced Development Assistant System -->
    <script type="module" src="ai-system/enhanced-development-assistant.js"></script>
    <script type="module" src="ai-system/enhanced-ai-integration.js"></script>
    
    <!-- Enhanced AI Terminal Integration -->
    <script type="module" src="enhanced-ai-terminal-init.js"></script>
    <!-- Initialize terminalState early to prevent undefined errors -->
    <script>
        // Initialize terminalState before any other scripts
        window.terminalState = {
            terminal: null,
            shellHarness: null,
            terminalWrapper: null,
            voiceEngine: null,
            advancedVoiceRecognition: null,
            isVoiceOutputEnabled: false
        };
    </script>
    
    <script type="module" src="terminal-functions-fix.js"></script>
    <script>
        // Terminal modules will be loaded via the preload script
        // Removing direct require() calls as they won't work without nodeIntegration
        
        let terminal;
        let terminalWrapper; // Use TerminalWrapper instead of direct shellProcess
        let shellHarness; // Shell harness for graceful command fallback
        let isVoiceActive = false;
        let recognition;
        let speechEngine;
        let voiceEngine;
        let aiAssistant;
        let advancedVoiceRecognition;
        let rinaPersonality;
        let rinaDialogue;
        let elevenLabsAgent = null;
        let isConversationalAIActive = false;
        
        // Enhanced Natural Language Processor - Much Smarter AI! (Moved to top for hoisting)
        const nlp = {
            // File operations - expanded
            'list files': 'Get-ChildItem',
            'show files': 'Get-ChildItem',
            'list all files': 'Get-ChildItem -Force',
            'show hidden files': 'Get-ChildItem -Force',
            'find files': 'Get-ChildItem -Recurse',
            'search files': 'Get-ChildItem -Recurse -Filter',
            'list directories': 'Get-ChildItem -Directory',
            'show folders': 'Get-ChildItem -Directory',
            'file count': '(Get-ChildItem).Count',
            'folder size': 'Get-ChildItem | Measure-Object -Property Length -Sum',
            'recent files': 'Get-ChildItem | Sort-Object LastWriteTime -Descending | Select-Object -First 10',
            'large files': 'Get-ChildItem -Recurse | Sort-Object Length -Descending | Select-Object -First 10',
            'empty folders': 'Get-ChildItem -Directory | Where-Object {(Get-ChildItem $_.FullName).Count -eq 0}',
            
            // Directory navigation - expanded
            'current directory': 'Get-Location',
            'where am i': 'Get-Location',
            'show directory': 'pwd',
            'current path': 'Get-Location',
            'working directory': 'Get-Location',
            'go home': 'Set-Location ~',
            'go to desktop': 'Set-Location ~/Desktop',
            'go to documents': 'Set-Location ~/Documents',
            'go to downloads': 'Set-Location ~/Downloads',
            'go to pictures': 'Set-Location ~/Pictures',
            'go up': 'Set-Location ..',
            'go back': 'Set-Location ..',
            'parent directory': 'Set-Location ..',
            'go to root': 'Set-Location C:/',
            'directory tree': 'tree /f',
            'directory structure': 'tree',
            
            // File management - expanded
            'create folder': 'New-Item -ItemType Directory -Name',
            'make directory': 'New-Item -ItemType Directory -Name',
            'create file': 'New-Item -ItemType File -Name',
            'make file': 'New-Item -ItemType File -Name',
            'delete file': 'Remove-Item',
            'remove file': 'Remove-Item',
            'copy file': 'Copy-Item',
            'move file': 'Move-Item',
            'rename file': 'Rename-Item',
            'file properties': 'Get-ItemProperty',
            'file permissions': 'Get-Acl',
            'file size': 'Get-ChildItem | Select-Object Name, Length',
            'compress files': 'Compress-Archive',
            'extract files': 'Expand-Archive',
            'backup files': 'Copy-Item -Recurse',
            
            // System information - expanded
            'show processes': 'Get-Process',
            'list processes': 'Get-Process',
            'running processes': 'Get-Process',
            'top processes': 'Get-Process | Sort-Object CPU -Descending | Select-Object -First 10',
            'memory processes': 'Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 10',
            'kill process': 'Stop-Process -Name',
            'system info': 'Get-ComputerInfo',
            'computer info': 'Get-ComputerInfo',
            'disk space': 'Get-PSDrive',
            'drives': 'Get-PSDrive -PSProvider FileSystem',
            'memory usage': 'Get-WmiObject Win32_OperatingSystem | Select-Object TotalPhysicalMemory, FreePhysicalMemory',
            'cpu info': 'Get-WmiObject Win32_Processor',
            'cpu usage': 'Get-Counter "\\Processor(_Total)\\% Processor Time"',
            'system uptime': 'Get-WmiObject Win32_OperatingSystem | Select-Object LastBootUpTime',
            'installed programs': 'Get-WmiObject Win32_Product',
            'windows version': 'Get-WmiObject Win32_OperatingSystem',
            'environment variables': 'Get-ChildItem Env:',
            'temp files': 'Get-ChildItem $env:TEMP',
            'services': 'Get-Service',
            'running services': 'Get-Service | Where-Object Status -eq Running',
            'startup programs': 'Get-WmiObject Win32_StartupCommand',
            
            // Git operations - expanded
            'git status': 'git status',
            'git log': 'git log --oneline -10',
            'git history': 'git log --oneline -20',
            'git branches': 'git branch -a',
            'git remote': 'git remote -v',
            'git add all': 'git add .',
            'git stage all': 'git add .',
            'git commit': 'git commit -m',
            'git push': 'git push',
            'git pull': 'git pull',
            'git fetch': 'git fetch',
            'git diff': 'git diff',
            'git stash': 'git stash',
            'git merge': 'git merge',
            'git checkout': 'git checkout',
            'git clone': 'git clone',
            'git init': 'git init',
            'git config': 'git config --list',
            'uncommitted changes': 'git status --porcelain',
            'recent commits': 'git log --oneline -5',
            
            // Development - expanded
            'install package': 'npm install',
            'install dependencies': 'npm install',
            'npm install': 'npm install',
            'yarn install': 'yarn install',
            'run tests': 'npm test',
            'test': 'npm test',
            'start server': 'npm start',
            'build project': 'npm run build',
            'run dev': 'npm run dev',
            'dev server': 'npm run dev',
            'package info': 'npm list',
            'outdated packages': 'npm outdated',
            'update packages': 'npm update',
            'npm scripts': 'npm run',
            'node version': 'node --version',
            'npm version': 'npm --version',
            'python version': 'python --version',
            'java version': 'java -version',
            'docker ps': 'docker ps',
            'docker images': 'docker images',
            'docker containers': 'docker ps -a',
            
            // Network - expanded
            'ping google': 'ping google.com',
            'ping test': 'ping 8.8.8.8',
            'show ip': 'ipconfig',
            'ip address': 'ipconfig',
            'network info': 'ipconfig /all',
            'network config': 'ipconfig /all',
            'dns info': 'nslookup',
            'network connections': 'netstat -an',
            'open ports': 'netstat -an | findstr LISTENING',
            'network adapters': 'Get-NetAdapter',
            'wifi networks': 'netsh wlan show profiles',
            'internet speed': 'Test-NetConnection',
            'trace route': 'tracert google.com',
            'flush dns': 'ipconfig /flushdns',
            
            // Windows specific - expanded
            'event logs': 'Get-EventLog System -Newest 10',
            'error logs': 'Get-EventLog System -EntryType Error -Newest 10',
            'windows updates': 'Get-HotFix',
            'installed updates': 'Get-HotFix',
            'registry query': 'Get-ItemProperty',
            'system files': 'sfc /scannow',
            'disk check': 'chkdsk C:',
            'defrag disk': 'defrag C: /A',
            'system restore': 'rstrui',
            'task manager': 'taskmgr',
            'device manager': 'devmgmt.msc',
            'control panel': 'control',
            'system properties': 'sysdm.cpl',
            'msconfig': 'msconfig',
            'regedit': 'regedit',
            
            // File search - expanded
            'find file': 'Get-ChildItem -Recurse -Name',
            'search for': 'Get-ChildItem -Recurse -Filter',
            'locate': 'Get-ChildItem -Recurse -Name',
            'where is': 'Get-ChildItem -Recurse -Name',
            'find text': 'Select-String -Path',
            'grep': 'Select-String',
            'search content': 'Select-String -Recurse',
            
            // Time and date
            'current time': 'Get-Date',
            'date': 'Get-Date',
            'time': 'Get-Date',
            'timestamp': 'Get-Date -Format "yyyy-MM-dd HH:mm:ss"',
            'timezone': 'Get-TimeZone',
            
            // Utilities
            'calculator': 'calc',
            'notepad': 'notepad',
            'paint': 'mspaint',
            'wordpad': 'write',
            'browser': 'start chrome',
            'file explorer': 'explorer',
            'command prompt': 'cmd',
            'powershell': 'powershell',
            
            // System cleanup
            'temp cleanup': 'Get-ChildItem $env:TEMP | Remove-Item -Recurse -Force',
            'recycle bin': 'Clear-RecycleBin',
            'disk cleanup': 'cleanmgr',
            
            // Help and information
            'help': 'Get-Help',
            'commands': 'Get-Command',
            'clear screen': 'Clear-Host',
            'clear': 'Clear-Host',
            'cls': 'Clear-Host',
            'exit': 'exit',
            'quit': 'exit',
            'version': '$PSVersionTable',
            'powershell version': '$PSVersionTable.PSVersion',
            
            // Fun commands
            'weather': 'curl wttr.in',
            'joke': 'curl -s https://api.jokes.one/jod',
            'quote': 'curl -s https://api.quotable.io/random',
            'ascii art': 'figlet',
            
            // Docker (if installed)
            'docker version': 'docker --version',
            'docker info': 'docker info',
            'docker containers': 'docker ps -a',
            'running containers': 'docker ps',
            'docker images': 'docker images',
            'docker volumes': 'docker volume ls',
            'docker networks': 'docker network ls'
        };
        
        // Advanced AI Engine with Context Awareness and Learning
        class AdvancedAI {
            constructor() {
                this.context = {
                    currentDirectory: '.',
                    lastCommands: [],
                    projectType: null,
                    userPreferences: {},
                    sessionHistory: []
                };
                this.patterns = nlp;
                this.synonyms = {
                    'show': ['display', 'view', 'see', 'get'],
                    'list': ['show', 'display', 'enumerate'],
                    'find': ['search', 'locate', 'look for'],
                    'create': ['make', 'new', 'add', 'generate'],
                    'delete': ['remove', 'rm', 'del', 'erase'],
                    'current': ['present', 'active', 'this'],
                    'files': ['documents', 'items', 'content']
                };
            }

            // Enhanced pattern matching with context and intent recognition
            findBestMatch(input) {
                const words = input.toLowerCase().split(' ');
                let bestMatch = null;
                let bestScore = 0;
                let intent = this.detectIntent(input);
                
                // Try exact matches first
                for (const [phrase, command] of Object.entries(this.patterns)) {
                    let score = this.calculateScore(input, phrase, words);
                    
                    // Boost score based on context
                    if (this.isContextRelevant(phrase, intent)) {
                        score += 25;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = { phrase, command, score, intent };
                    }
                }
                
                // If no good match, try semantic alternatives
                if (!bestMatch || bestMatch.score < 30) {
                    bestMatch = this.trySemanticMatch(input, words, intent);
                }
                
                return bestMatch && bestMatch.score > 15 ? bestMatch : null;
            }

            calculateScore(input, phrase, words) {
                const phraseWords = phrase.split(' ');
                let score = 0;
                
                // Exact phrase match
                if (input.includes(phrase)) {
                    return 100;
                }
                
                // Word-by-word matching with synonyms
                phraseWords.forEach(phraseWord => {
                    words.forEach(inputWord => {
                        if (inputWord === phraseWord) {
                            score += 20;
                        } else if (this.areSynonyms(inputWord, phraseWord)) {
                            score += 15;
                        } else if (inputWord.includes(phraseWord) || phraseWord.includes(inputWord)) {
                            score += 8;
                        }
                    });
                });
                
                return score;
            }

            detectIntent(input) {
                const lower = input.toLowerCase();
                if (lower.includes('what') || lower.includes('show') || lower.includes('tell')) {
                    return 'query';
                } else if (lower.includes('create') || lower.includes('make') || lower.includes('new')) {
                    return 'create';
                } else if (lower.includes('delete') || lower.includes('remove') || lower.includes('rm')) {
                    return 'delete';
                } else if (lower.includes('go') || lower.includes('cd') || lower.includes('navigate')) {
                    return 'navigate';
                } else if (lower.includes('run') || lower.includes('execute') || lower.includes('start')) {
                    return 'execute';
                }
                return 'general';
            }

            isContextRelevant(phrase, intent) {
                if (intent === 'query' && (phrase.includes('show') || phrase.includes('list'))) {
                    return true;
                }
                if (intent === 'navigate' && phrase.includes('directory')) {
                    return true;
                }
                return false;
            }

            areSynonyms(word1, word2) {
                for (const [key, synonyms] of Object.entries(this.synonyms)) {
                    if ((key === word1 || synonyms.includes(word1)) && 
                        (key === word2 || synonyms.includes(word2))) {
                        return true;
                    }
                }
                return false;
            }

            trySemanticMatch(input, words, intent) {
                // Try to understand user's intent even with different wording
                const semanticPatterns = {
                    'directory': ['pwd', 'Get-Location'],
                    'folder': ['directory', 'pwd'],
                    'path': ['pwd', 'Get-Location'],
                    'where': ['Get-Location'],
                    'location': ['Get-Location']
                };

                for (const word of words) {
                    if (semanticPatterns[word]) {
                        return {
                            phrase: `semantic match: ${word}`,
                            command: semanticPatterns[word][0],
                            score: 25,
                            intent: intent,
                            semantic: true
                        };
                    }
                }

                return null;
            }

            // Learn from user interactions
            learn(input, selectedCommand, wasSuccessful) {
                this.context.sessionHistory.push({
                    input,
                    command: selectedCommand,
                    successful: wasSuccessful,
                    timestamp: new Date().toISOString()
                });

                // Keep only last 50 interactions for memory efficiency
                if (this.context.sessionHistory.length > 50) {
                    this.context.sessionHistory.shift();
                }
            }

            // Generate contextual suggestions
            getSuggestions(input) {
                const suggestions = [];
                const intent = this.detectIntent(input);

                if (intent === 'query') {
                    suggestions.push('show processes', 'list files', 'current directory');
                } else if (intent === 'navigate') {
                    suggestions.push('go home', 'go up', 'show directory');
                } else {
                    suggestions.push('git status', 'list files', 'system info');
                }

                return suggestions;
            }

            // Provide intelligent responses
            generateResponse(match, input) {
                if (!match) {
                    const suggestions = this.getSuggestions(input);
                    return {
                        response: `üßú‚Äç‚ôÄÔ∏è *adjusts seashell crown* I didn't quite catch that, sweetie! Did you mean one of these?`,
                        suggestions: suggestions,
                        confidence: 0.1
                    };
                }

                let response;
                if (match.semantic) {
                    response = `üß† Smart AI: I understand you want "${match.phrase}" ‚Üí <code>${match.command}</code>`;
                } else {
                    response = `üßú‚Äç‚ôÄÔ∏è Mermaid AI: "${match.phrase}" ‚Üí <code>${match.command}</code>`;
                }

                return {
                    response: response,
                    confidence: match.score / 100,
                    suggestions: this.getSuggestions(input),
                    intent: match.intent
                };
            }
        }
        
        // Create global AI instance
        const advancedAI = new AdvancedAI();
        
        // Backward compatibility function
        function findBestMatch(input) {
            return advancedAI.findBestMatch(input);
        }
        
        async function initTerminal() {
            updateStatus('üöÄ Creating AI-powered terminal...');
            
            try {
                // Initialize terminal wrapper
                terminalWrapper = new TerminalWrapper();
                await terminalWrapper.initialize('terminal');
                
                // Get the actual terminal instance for backward compatibility
                terminal = terminalWrapper.terminal;
                
                // Store references in terminalState for the fix script
                window.terminalState.terminal = terminal;
                window.terminalState.terminalWrapper = terminalWrapper;
                
                // Initialize shell harness with terminal wrapper
                try {
                    // Import shell harness module
                    const { ShellHarness } = await import('./renderer/shell-harness.js');
                    shellHarness = new ShellHarness({ 
                        fallback: false, 
                        terminalWrapper: terminalWrapper 
                    });
                    console.log('‚úÖ Shell harness initialized with terminal wrapper');
                    
                    // Store shellHarness after successful initialization
                    window.terminalState.shellHarness = shellHarness;
                } catch (harnessError) {
                    console.warn('Shell harness initialization failed, using fallback mode:', harnessError);
                    // Create fallback shell harness
                    const { ShellHarness } = await import('./renderer/shell-harness.js');
                    shellHarness = new ShellHarness({ fallback: true });
                    
                    // Store fallback shellHarness
                    window.terminalState.shellHarness = shellHarness;
                }
                
                updateStatus('‚úÖ RinaWarp Terminal ready! Use AI commands above or type directly.');
                
            } catch (terminalError) {
                console.error('Failed to initialize terminal:', terminalError);
                updateStatus(`‚ùå Terminal initialization failed: ${terminalError.message}`);
                
                // Initialize shell harness in fallback mode
                try {
                    const { ShellHarness } = await import('./renderer/shell-harness.js');
                    shellHarness = new ShellHarness({ fallback: true });
                    updateStatus('‚ö†Ô∏è Terminal unavailable - using AI simulation mode');
                } catch (harnessError) {
                    console.error('Failed to initialize shell harness:', harnessError);
                }
                
                // Create fallback terminal display
                const terminalElement = document.getElementById('terminal');
                if (terminalElement) {
                    terminalElement.innerHTML = 
                        '<div style="color: #ff6b6b; padding: 20px; text-align: center; font-family: monospace;">' +
                        '‚ùå Terminal failed to initialize<br><br>' +
                        'Error: ' + terminalError.message + '<br><br>' +
                        'üßú‚Äç‚ôÄÔ∏è The AI assistant above is still available for commands.<br>' +
                        '‚ú® Using simulation mode for command responses.<br>' +
                        'Please refresh the page to try again.' +
                        '</div>';
                }
                return;
            }
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('[Status]', message);
        }
        
        // Toggle advanced controls visibility
        function toggleAdvancedControls() {
            const controls = document.getElementById('advancedControls');
            const button = document.getElementById('advancedToggle');
            
            if (controls.style.display === 'none') {
                controls.style.display = 'block';
                button.textContent = 'üîß Hide Tools';
                button.style.background = 'linear-gradient(45deg, #FF1493, #00FF88, #8A2BE2)';
            } else {
                controls.style.display = 'none';
                button.textContent = 'üîß Advanced Tools';
                button.style.background = '';
            }
        }
        
        let isVoiceOutputEnabled = false;
        function toggleVoiceOutput() {
            isVoiceOutputEnabled = !isVoiceOutputEnabled;
            const btn = document.getElementById('voiceOutputBtn');
            btn.textContent = isVoiceOutputEnabled ? "üîä Voice Output: ON" : "üîä Voice Output: OFF";
        }

        async function processAICommand() {
            const input = document.getElementById('aiInput').value.trim();
            const responseDiv = document.getElementById('aiResponse');
            
            if (!input) {
                responseDiv.innerHTML = 'üßú‚Äç‚ôÄÔ∏è <em>*flips tail impatiently*</em> Come on darling, give me something to work with!';
                return;
            }
            
            // Show processing
            responseDiv.innerHTML = 'üåä <em>Swimming through the data currents...</em>';
            
            try {
                let result;
                
                // Use enhanced AI system if available
                if (window.rinaWarpAI && window.rinaWarpAI.getSystemStatus().initialized) {
                    result = await window.rinaWarpAI.processCommand(input);
                    
                    // Display comprehensive AI response
                    const systemStatus = window.rinaWarpAI.getSystemStatus();
                    responseDiv.innerHTML = `
                        <div style="color: #FF1493; font-weight: bold;">${result.response || result.message}</div>
                        <div style="color: #00AAFF; font-size: 12px; margin-top: 5px;">
                            üéØ Confidence: ${Math.round((result.confidence || 0) * 100)}% | 
                            üß† Source: ${result.source || 'unknown'} | 
                            ‚ö° ${result.processingTime || 0}ms
                        </div>
                        ${result.suggestions && result.suggestions.length > 0 ? 
                            `<div style="color: #00FF88; margin-top: 5px;">üí° Try: ${result.suggestions.slice(0, 3).join(', ')}</div>` : ''}
                        ${result.learningInsights ? 
                            `<div style="color: #8A2BE2; font-size: 11px; margin-top: 5px;">
                                üìö Skill: ${result.learningInsights.skillLevel} | 
                                üìä Accuracy: ${Math.round((result.learningInsights.accuracyScore || 0) * 100)}%
                                ${result.learningInsights.nextPrediction ? ` | üîÆ Next: ${result.learningInsights.nextPrediction.command}` : ''}
                            </div>` : ''}
                        <div style="color: #74c0fc; font-size: 10px; margin-top: 5px; opacity: 0.8;">
                            Mode: ${systemStatus.currentMode} | 
                            Session: ${systemStatus.performanceMetrics ? systemStatus.performanceMetrics.totalRequests : 0} requests
                        </div>
                    `;
                    
                    // Execute command if it was successfully interpreted and shell harness is available
                    if (result.response.includes('‚Üí') && shellHarness) {
                        // Extract command from response (simple parsing)
                        const commandMatch = result.response.match(/`([^`]+)`/);
                        if (commandMatch) {
                            const command = commandMatch[1];
                            try {
                                await shellHarness.execute(command);
                                terminal.write(`\r\nü§ñ AI Command: ${command}\r\n`);
                            } catch (execError) {
                                console.error('AI command execution failed:', execError);
                            }
                        }
                    }
                } else {
                    // Fallback to original logic
                    if (window.aiManager && window.aiManager.isInitialized) {
                        const aiResult = await window.aiManager.processUserCommand(input, {
                            timestamp: new Date().toISOString(),
                            sessionId: window.aiManager.sessionId
                        });
                        
                        responseDiv.innerHTML = `
                            <div style="color: #FF1493; font-weight: bold;">${aiResult.response}</div>
                            ${aiResult.explanation ? `<div style="margin-top: 10px; color: #00AAFF;">${aiResult.explanation}</div>` : ''}
                            ${aiResult.tips && aiResult.tips.length > 0 ? 
                                `<div style="margin-top: 10px; color: #00FF88;">
                                    <strong>üí° Mermaid Tips:</strong><br>
                                    ${aiResult.tips.map(tip => `‚Ä¢ ${tip}`).join('<br>')}
                                </div>` : ''}
                            ${aiResult.safety && aiResult.safety.risk_level !== 'low' ? 
                                `<div style="margin-top: 10px; color: #FFD700;">
                                    <strong>‚ö†Ô∏è Safety Notice:</strong> ${aiResult.safety.risk_level} risk detected
                                </div>` : ''}
                        `;
                    } else {
                        // Legacy mode - find matching command
                        const match = findBestMatch(input);
                        
                        if (match) {
                            responseDiv.innerHTML = `
                                <div>üßú‚Äç‚ôÄÔ∏è Mermaid AI: "${match.phrase}" ‚Üí <code>${match.command}</code></div>
                                <div style="margin-top: 5px; color: #74c0fc;">‚ú® Making waves with this command...</div>
                            `;
                            
                            // Execute command using shell harness
                            try {
                                const executionResult = await shellHarness.execute(match.command);
                                terminal.write(`\r\nüßú‚Äç‚ôÄÔ∏è Mermaid AI Command: ${match.command}\r\n`);
                            } catch (executionError) {
                                responseDiv.innerHTML += `
                                    <div style="margin-top: 5px; color: #FF6B6B;">‚ùå Command execution failed: ${executionError.message}</div>
                                `;
                            }
                        } else {
                            responseDiv.innerHTML = `
                                <div style="color: #FF1493;">üßú‚Äç‚ôÄÔ∏è <em>*adjusts seashell crown*</em> Sorry sweetie, "${input}" isn't in my underwater vocabulary!</div>
                                <div style="color: #ffd93d; margin-top: 10px;">üêö Try asking about: git, docker, npm, files, or system info</div>
                                <div style="color: #00AAFF; margin-top: 5px;">üí° Or just say "help" for my full repertoire of oceanic wisdom!</div>
                            `;
                        }
                    }
                }
                
                // Add some mermaid flair to successful responses
                if (!responseDiv.innerHTML.includes('Sorry') && !responseDiv.innerHTML.includes('understand')) {
                    const mermiaidEmojis = ['üåä', 'üßú‚Äç‚ôÄÔ∏è', 'üêö', 'üêô', 'üê≥', 'üå∫', '‚ú®'];
                    const randomEmoji = mermiaidEmojis[Math.floor(Math.random() * mermiaidEmojis.length)];
                    responseDiv.innerHTML += `<div style="text-align: right; margin-top: 10px; opacity: 0.7;">${randomEmoji}</div>`;
                }
                
                // Speak the response if voice output is enabled
                if (isVoiceOutputEnabled && voiceEngine && voiceEngine.isInitialized) {
                    // Extract clean text from the response for speech
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = responseDiv.innerHTML;
                    let textToSpeak = tempDiv.textContent || tempDiv.innerText || '';
                    
                    // Clean up the text - remove emojis and extra formatting
                    textToSpeak = textToSpeak
                        .replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄüîÆüìöüìäüí°üéØüß†]/g, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    // Only speak meaningful content
                    if (textToSpeak && textToSpeak.length > 5) {
                        voiceEngine.speak(textToSpeak);
                    }
                }
                
            } catch (error) {
                console.error('AI processing error:', error);
                responseDiv.innerHTML = `
                    <div style="color: #FF6B6B;">üßú‚Äç‚ôÄÔ∏è <em>*bubbles of confusion*</em> Even mermaids have off days!</div>
                    <div style="color: #FFD93D; margin-top: 5px;">Error: ${error.message}</div>
                `;
            }
            
            // Clear input
            document.getElementById('aiInput').value = '';
        }
        
        function startVoiceControl() {
            if (!advancedVoiceRecognition) {
                updateStatus('‚ùå Voice systems not initialized. Please refresh the page.');
                return;
            }

            try {
                const providerInfo = advancedVoiceRecognition.getProviderInfo();
                
                if (!providerInfo.isListening) {
                    advancedVoiceRecognition.start();
                    // Enable voice mode if AI assistant is available
                    if (window.aiAssistant) {
                        window.aiAssistant.enableVoiceMode();
                    }
                } else {
                    advancedVoiceRecognition.stop();
                    // Disable voice mode if AI assistant is available
                    if (window.aiAssistant) {
                        window.aiAssistant.disableVoiceMode();
                    }
                }
            } catch (error) {
                console.error('Voice control error:', error);
                updateStatus(`‚ùå Voice control error: ${error.message}`);
            }
        }
        
        function showAIHelp() {
            const helpText = `
ü§ñ RinaWarp AI Assistant Commands:

üìÅ FILE OPERATIONS:
‚Ä¢ "list files" - Show files in directory
‚Ä¢ "show hidden files" - Include hidden files
‚Ä¢ "find files" - Search recursively

üìÇ NAVIGATION:
‚Ä¢ "current directory" - Show where you are
‚Ä¢ "go home" - Navigate to home directory
‚Ä¢ "go to desktop" - Navigate to Desktop

üîß SYSTEM:
‚Ä¢ "show processes" - List running processes
‚Ä¢ "system info" - Computer information
‚Ä¢ "disk space" - Show drive usage

üî® DEVELOPMENT:
‚Ä¢ "git status" - Check git repository
‚Ä¢ "install package" - Run npm install
‚Ä¢ "run tests" - Execute npm test

üé§ VOICE:
‚Ä¢ Say "Hey Rina" + any command above
‚Ä¢ Example: "Hey Rina, list files"

üí° TIP: You can also type PowerShell commands directly in the terminal!
            `;
            alert(helpText);
        }
        
        async function runCommand() {
            const cmd = await new Promise(resolve => {
                const inputModal = document.createElement('div');
                inputModal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.8); display: flex; align-items: center;
                    justify-content: center; z-index: 1000;
                `;
                inputModal.innerHTML = `
                    <div style="background: #2d2d2d; padding: 30px; border-radius: 10px; max-width: 400px; width: 100%; text-align: center;">
                        <h4 style="color: #00ff88; margin-top: 0;">Enter PowerShell Command</h4>
                        <input type="text" id="commandInput" style="width: 80%; padding: 10px; margin-bottom: 10px;">
                        <button id="runCmdButton" style="padding: 10px 20px; background: #007acc; color: white; border: none; border-radius: 5px; cursor: pointer;">Run</button>
                        <button id="closeCmdButton" style="padding: 10px 20px; background: #999; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">Close</button>
                    </div>
                `;
                document.body.appendChild(inputModal);

                document.getElementById('commandInput').focus();

                document.getElementById('runCmdButton').onclick = () => {
                    const command = document.getElementById('commandInput').value;
                    document.body.removeChild(inputModal);
                    resolve(command);
                };

                document.getElementById('closeCmdButton').onclick = () => {
                    document.body.removeChild(inputModal);
                    resolve(null);
                };
            });
            if (cmd && shellHarness) {
                try {
                    await shellHarness.execute(cmd);
                    terminal.write(`\r\n‚ö° Quick Command: ${cmd}\r\n`);
                } catch (execError) {
                    console.error('Quick command execution failed:', execError);
                    terminal.write(`\r\n‚ùå Command execution failed: ${execError.message}\r\n`);
                }
            }
        }
        
        function clearTerminal() {
            if (terminal) {
                terminal.clear();
                terminal.write('üßπ Terminal cleared\r\n\r\n');
            }
        }
        
        // Natural Language Agent Mode - Enhanced AI interaction
        function startNaturalLanguageAgent() {
            const agentSection = document.getElementById('aiAgentSection');
            const agentBtn = document.getElementById('agentModeBtn');
            const aiInput = document.getElementById('aiInput');
            
            // Toggle agent section visibility
            if (agentSection.style.display === 'none') {
                agentSection.style.display = 'block';
                agentBtn.textContent = 'ü§ñ AI Agent: ON';
                agentBtn.style.background = 'linear-gradient(45deg, #00FF88, #00AAFF, #FF1493)';
                updateStatus('ü§ñ Natural Language AI Agent activated! Ask me anything.');
                
                // Show welcome message
                const responseDiv = document.getElementById('aiResponse');
                responseDiv.innerHTML = `
                    <div style="color: #FF1493; font-weight: bold;">
                        üßú‚Äç‚ôÄÔ∏è *emerges from digital depths* Hello! I'm Rina, your AI terminal assistant!
                    </div>
                    <div style="color: #00AAFF; margin-top: 10px;">
                        I can understand natural language and help you with:
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>üìÅ File operations ("show me my files", "create a new folder")</li>
                            <li>üîß System tasks ("what processes are running?", "check disk space")</li>
                            <li>üî® Development ("git status", "run tests", "install packages")</li>
                            <li>üåê Network ("ping google", "show my IP address")</li>
                        </ul>
                        Just talk to me naturally, like "Can you list the files in my current directory?"
                    </div>
                    <div style="color: #8A2BE2; margin-top: 15px; font-size: 14px;">
                        üí° Pro tip: I understand context and can handle complex requests!
                    </div>
                `;
                
                // Focus on input and add placeholder
                aiInput.focus();
                aiInput.placeholder = "Ask me anything... (e.g., 'What files are in this directory?')";
                
            } else {
                agentSection.style.display = 'none';
                agentBtn.textContent = 'ü§ñ AI Agent';
                agentBtn.style.background = '';
                updateStatus('ü§ñ Natural Language AI Agent deactivated.');
            }
        }
        
        function showFeatures() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; align-items: center;
                justify-content: center; z-index: 1000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: #2d2d2d; padding: 30px; border-radius: 10px;
                    max-width: 600px; max-height: 80%; overflow-y: auto;
                    border: 2px solid #555;
                ">
                    <h2 style="color: #00ff88; margin-top: 0;">‚ú® RinaWarp Terminal Features</h2>
                    
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>ü§ñ AI Assistant</h4>
                            <p>Natural language commands</p>
                        </div>
                        <div class="feature-card">
                            <h4>üé§ Voice Control</h4>
                            <p>Talk to your terminal</p>
                        </div>
                        <div class="feature-card">
                            <h4>‚ö° PowerShell</h4>
                            <p>Full Windows PowerShell</p>
                        </div>
                        <div class="feature-card">
                            <h4>üé® Modern UI</h4>
                            <p>Beautiful interface</p>
                        </div>
                    </div>
                    
                    <h3 style="color: #74c0fc;">üöÄ Coming Soon:</h3>
                    <ul style="color: #ffd93d;">
                        <li>Cloud sync across devices</li>
                        <li>Team collaboration features</li>
                        <li>Advanced AI workflows</li>
                        <li>Custom themes and plugins</li>
                    </ul>
                    
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="margin-top: 20px; padding: 10px 20px; background: #007acc; 
                                   color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        async function configureElevenLabs() {
            try {
                // Check if electronAPI is available
                if (!window.electronAPI) {
                    console.error('electronAPI not available');
                    alert('ElevenLabs configuration is not available in this context');
                    return;
                }
                
                // Load the ElevenLabs configuration via IPC
                const currentConfig = await window.electronAPI.loadElevenLabsConfig();
                
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.8); display: flex; align-items: center;
                    justify-content: center; z-index: 1000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: #2d2d2d; padding: 30px; border-radius: 10px;
                        max-width: 500px; width: 90%; border: 2px solid #555;
                    ">
                        <h2 style="color: #00ff88; margin-top: 0;">üé§ ElevenLabs Configuration</h2>
                        
                        <div style="margin: 20px 0;">
                            <label style="color: #fff; display: block; margin-bottom: 10px;">API Key:</label>
                            <input type="password" id="elevenLabsApiKey" 
                                   placeholder="Enter your ElevenLabs API key" 
                                   value="${currentConfig.apiKey || ''}" 
                                   style="width: 100%; padding: 10px; background: #444; color: white; 
                                          border: 1px solid #666; border-radius: 5px;">
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <label style="color: #fff; display: block; margin-bottom: 10px;">Voice ID (optional):</label>
                            <select id="elevenLabsVoiceId" 
                                    style="width: 100%; padding: 10px; background: #444; color: white; 
                                           border: 1px solid #666; border-radius: 5px;">
                                <option value="">Default Voice</option>
                                <option value="EXAVITQu4vr4xnSDxMaL" ${currentConfig.voiceId === 'EXAVITQu4vr4xnSDxMaL' ? 'selected' : ''}>Bella</option>
                                <option value="ErXwobaYiN019PkySvjV" ${currentConfig.voiceId === 'ErXwobaYiN019PkySvjV' ? 'selected' : ''}>Antoni</option>
                                <option value="MF3mGyEYCl7XYWbV9V6O" ${currentConfig.voiceId === 'MF3mGyEYCl7XYWbV9V6O' ? 'selected' : ''}>Elli</option>
                                <option value="TxGEqnHWrfWFTfGW9XjX" ${currentConfig.voiceId === 'TxGEqnHWrfWFTfGW9XjX' ? 'selected' : ''}>Josh</option>
                            </select>
                        </div>
                        
                        <div style="margin: 20px 0; color: #ccc; font-size: 12px;">
                            <p>üìã To get your API key:</p>
                            <ol>
                                <li>Visit <a href="https://elevenlabs.io" target="_blank" style="color: #74c0fc;">ElevenLabs.io</a></li>
                                <li>Sign up or log in to your account</li>
                                <li>Go to Profile ‚Üí API Keys</li>
                                <li>Copy your API key and paste it above</li>
                            </ol>
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px;">
                            <button onclick="saveElevenLabsConfig()" 
                                    style="padding: 10px 20px; background: #007acc; color: white; 
                                           border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">Save Configuration</button>
                            <button onclick="testElevenLabsVoice()" 
                                    style="padding: 10px 20px; background: #28a745; color: white; 
                                           border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">Test Voice</button>
                            <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                                    style="padding: 10px 20px; background: #999; color: white; 
                                           border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Close on click outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Error loading ElevenLabs configuration:', error);
                alert('Failed to load ElevenLabs configuration: ' + error.message);
            }
        }
        
        async function saveElevenLabsConfig() {
            try {
                const apiKey = document.getElementById('elevenLabsApiKey').value.trim();
                const voiceId = document.getElementById('elevenLabsVoiceId').value;
                
                if (!apiKey) {
                    alert('Please enter an API key');
                    return;
                }
                
                // Check if electronAPI is available
                if (!window.electronAPI) {
                    console.error('electronAPI not available');
                    alert('Cannot save configuration - electronAPI not available');
                    return;
                }
                
                // Save configuration via IPC
                const result = await window.electronAPI.saveElevenLabsConfig({ apiKey, voiceId });
                
                if (result.success) {
                    alert('‚úÖ ElevenLabs configuration saved successfully!');
                    // Close the modal
                    document.querySelector('.modal')?.remove();
                    // Update status
                    updateStatus('‚úÖ ElevenLabs configured and ready');
                } else {
                    alert('‚ùå Failed to save configuration: ' + (result.error || 'Unknown error'));
                }
                
            } catch (error) {
                console.error('Error saving ElevenLabs configuration:', error);
                alert('Failed to save configuration: ' + error.message);
            }
        }
        
        async function testElevenLabsVoice() {
            try {
                const apiKey = document.getElementById('elevenLabsApiKey').value.trim();
                const voiceId = document.getElementById('elevenLabsVoiceId').value;
                
                if (!apiKey) {
                    alert('Please enter an API key first');
                    return;
                }
                
                updateStatus('üé§ Testing ElevenLabs voice...');
                
                // Check if electronAPI is available
                if (!window.electronAPI) {
                    updateStatus('‚ùå electronAPI not available');
                    alert('‚ùå electronAPI not available');
                    return;
                }
                
                try {
                    // Test via the main process
                    const testResult = await window.electronAPI.testElevenLabsVoice({
                        apiKey: apiKey,
                        voiceId: voiceId || 'EXAVITQu4vr4xnSDxMaL'
                    });
                    
                    if (testResult && testResult.success) {
                        updateStatus('‚úÖ Voice test successful!');
                        alert(`‚úÖ ${testResult.message || 'Voice test completed successfully'}\n\nVoice ID: ${testResult.voiceId || voiceId}`);
                    } else {
                        updateStatus('‚ùå Voice test failed');
                        alert(`‚ùå ${testResult?.message || 'Voice test failed - please check your API key and try again'}`);
                    }
                } catch (ipcError) {
                    console.warn('IPC test failed, trying fallback method:', ipcError);
                    
                    // Fallback: Initialize local agent if available
                    if (window.ElevenLabsAgentIntegration && window.elevenLabsAgent) {
                        await window.elevenLabsAgent.updateConfig(apiKey, voiceId);
                        
                        // Test the voice
                        const testResult = await window.elevenLabsAgent.testVoice();
                        
                        if (testResult && testResult.success) {
                            updateStatus('‚úÖ Voice test successful!');
                            alert(`‚úÖ ${testResult.message}\n\nVoice ID: ${testResult.voiceId}`);
                        } else {
                            updateStatus('‚ùå Voice test failed');
                            alert(`‚ùå ${testResult?.message || 'Voice test failed'}`);
                        }
                    } else {
                        updateStatus('‚ùå ElevenLabs integration not available');
                        alert('‚ùå ElevenLabs integration not available - please check your configuration');
                    }
                }
                
            } catch (error) {
                console.error('Error testing ElevenLabs voice:', error);
                updateStatus('‚ùå Voice test failed');
                alert('Voice test failed: ' + error.message);
            }
        }
        
        // Handle enter key in AI input
        document.addEventListener('DOMContentLoaded', () => {
            const aiInput = document.getElementById('aiInput');
            aiInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    processAICommand();
                }
            });
            
            // Focus on AI input by default
            aiInput.focus();
        });
        
        // Initialize terminal when page loads
        window.addEventListener('DOMContentLoaded', initTerminal);
        
        // Prevent context menu for cleaner experience
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Enhanced Speech Recognition Engine with Multiple Providers
        class SpeechRecognitionEngine {
            constructor() {
                this.isListening = false;
                this.recognition = null;
                this.wakeWords = ['hey rina', 'hello rina', 'rina'];
                this.stopWords = ['stop listening', 'stop voice', 'stop rina'];
                this.confidence = 0;
                this.lastCommand = '';
                this.onCommand = null;
                this.onStatusChange = null;
                this.provider = 'web-speech'; // 'web-speech', 'mock', 'keyboard'
                this.errorCount = 0;
                this.maxErrors = 3;
                this.isInitialized = false;
            }

            async init() {
                console.log('Initializing speech recognition...');
                
                // Try Web Speech API first
                if (this.tryWebSpeechAPI()) {
                    this.provider = 'web-speech';
                    console.log('Using Web Speech API');
                    return true;
                }
                
                // Fallback to mock/keyboard input
                console.warn('Web Speech API not available, using keyboard fallback');
                this.provider = 'keyboard';
                this.setupKeyboardFallback();
                return true;
            }

            tryWebSpeechAPI() {
                try {
                    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                        return false;
                    }

                    this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'en-US';
                    this.recognition.maxAlternatives = 3;

                    // Add Electron-specific configurations
                    if (typeof process !== 'undefined' && process.versions && process.versions.electron) {
                        console.log('Detected Electron environment, applying workarounds...');
                        // Some Electron-specific settings that might help
                        this.recognition.serviceURI = 'wss://www.google.com/speech-api/full-duplex/v1/up';
                    }

                    this.recognition.onstart = () => {
                        this.isListening = true;
                        this.errorCount = 0;
                        if (this.onStatusChange) this.onStatusChange('listening');
                    };

                    this.recognition.onresult = (event) => {
                        this.handleResult(event);
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        this.errorCount++;
                        
                        // Handle specific errors
                        switch(event.error) {
                            case 'network':
                                if (this.errorCount >= this.maxErrors) {
                                    console.warn('Too many network errors, switching to keyboard fallback');
                                    this.switchToKeyboardFallback();
                                    return;
                                }
                                break;
                            case 'not-allowed':
                                if (this.onStatusChange) {
                                    this.onStatusChange('error', 'microphone-denied');
                                }
                                return;
                            case 'no-speech':
                                // Auto-restart for no-speech errors
                                setTimeout(() => {
                                    if (!this.isListening) {
                                        this.start();
                                    }
                                }, 1000);
                                break;
                        }
                        
                        if (this.onStatusChange) this.onStatusChange('error', event.error);
                    };

                    this.recognition.onend = () => {
                        this.isListening = false;
                        if (this.onStatusChange) this.onStatusChange('stopped');
                        
                        // Auto-restart if we're supposed to be listening
                        if (this.provider === 'web-speech' && this.errorCount < this.maxErrors) {
                            setTimeout(() => {
                                if (!this.isListening) {
                                    this.start();
                                }
                            }, 500);
                        }
                    };

                    this.isInitialized = true;
                    return true;
                } catch (error) {
                    console.error('Failed to initialize Web Speech API:', error);
                    return false;
                }
            }

            setupKeyboardFallback() {
                console.log('Setting up keyboard fallback for voice commands');
                
                // Add a visual indicator that we're in keyboard mode
                this.showKeyboardModeUI();
                
                // Set up keyboard shortcut (Ctrl+Shift+V for voice command)
                document.addEventListener('keydown', (event) => {
                    if (event.ctrlKey && event.shiftKey && event.key === 'V') {
                        event.preventDefault();
                        this.promptForVoiceCommand();
                    }
                });
                
                this.isInitialized = true;
            }

            showKeyboardModeUI() {
                // Update the voice control button to show keyboard mode
                const voiceButton = document.querySelector('button[onclick="startVoiceControl()"]');
                if (voiceButton) {
                    voiceButton.innerHTML = '‚å®Ô∏è Voice (Keyboard) <span class="voice-indicator" id="voiceIndicator"></span>';
                    voiceButton.title = 'Press Ctrl+Shift+V for voice command input';
                }
                
                // Show notification
                if (this.onStatusChange) {
                    this.onStatusChange('keyboard-mode');
                }
            }

            promptForVoiceCommand() {
                const command = prompt('üé§ Voice Command (type your command):\n\nExamples:\n‚Ä¢ list files\n‚Ä¢ current directory\n‚Ä¢ git status\n‚Ä¢ show processes');
                
                if (command && command.trim()) {
                    // Simulate voice command processing
                    this.handleVoiceInput(command.trim(), 1.0);
                }
            }

            switchToKeyboardFallback() {
                console.log('Switching to keyboard fallback due to speech recognition issues');
                this.provider = 'keyboard';
                this.isListening = false;
                
                if (this.recognition) {
                    this.recognition.stop();
                }
                
                this.setupKeyboardFallback();
                
                // Notify user
                alert('üé§‚û°Ô∏è‚å®Ô∏è Voice recognition switched to keyboard mode due to connection issues.\n\nUse Ctrl+Shift+V to input voice commands via keyboard.');
            }

            handleVoiceInput(transcript, confidence) {
                console.log('Processing voice input:', transcript, 'Confidence:', confidence);
                
                // Check for wake words and extract command
                let command = null;
                const lowerTranscript = transcript.toLowerCase();
                
                for (const wakeWord of this.wakeWords) {
                    if (lowerTranscript.includes(wakeWord)) {
                        command = lowerTranscript.replace(wakeWord, '').trim();
                        break;
                    }
                }
                
                // In keyboard mode, assume direct command input
                if (this.provider === 'keyboard' && !command) {
                    command = transcript;
                }
                
                if (command && this.onCommand) {
                    this.onCommand(command, confidence);
                }
            }

            handleResult(event) {
                const result = event.results[event.results.length - 1];
                const transcript = result[0].transcript.toLowerCase().trim();
                this.confidence = result[0].confidence;
                this.lastCommand = transcript;

                console.log('Speech result:', transcript, 'Confidence:', this.confidence);

                // Check for stop commands
                if (this.stopWords.some(word => transcript.includes(word))) {
                    this.stop();
                    return;
                }

                // Check for wake words and extract command
                let command = null;
                for (const wakeWord of this.wakeWords) {
                    if (transcript.includes(wakeWord)) {
                        command = transcript.replace(wakeWord, '').trim();
                        break;
                    }
                }

                if (command && this.onCommand && result.isFinal) {
                    this.onCommand(command, this.confidence);
                }
            }

            async start() {
                if (!this.isInitialized) {
                    await this.init();
                }
                
                if (this.provider === 'web-speech') {
                    if (this.recognition && !this.isListening) {
                        try {
                            this.recognition.start();
                        } catch (error) {
                            console.error('Failed to start speech recognition:', error);
                            this.switchToKeyboardFallback();
                        }
                    }
                } else if (this.provider === 'keyboard') {
                    // In keyboard mode, clicking the button opens the prompt
                    this.promptForVoiceCommand();
                }
            }

            stop() {
                if (this.provider === 'web-speech' && this.recognition && this.isListening) {
                    this.recognition.stop();
                }
                this.isListening = false;
            }

            toggle() {
                if (this.isListening) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        // Voice Synthesis Engine
        class VoiceSynthesisEngine {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voice = null;
                this.customVoice = null;
                this.settings = {
                    rate: 1.0,
                    pitch: 1.0,
                    volume: 0.8,
                    useCustomVoice: false
                };
                this.isInitialized = false;
            }

            async init() {
                if (!this.synth) {
                    throw new Error('Speech synthesis not supported');
                }

                // Wait for voices to load
                return new Promise((resolve) => {
                    const loadVoices = () => {
                        const voices = this.synth.getVoices();
                        if (voices.length > 0) {
                            this.voice = voices.find(v => v.lang.startsWith('en-')) || voices[0];
                            this.isInitialized = true;
                            console.log('Voice synthesis initialized with voice:', this.voice.name);
                            resolve();
                        } else {
                            setTimeout(loadVoices, 100);
                        }
                    };
                    loadVoices();
                });
            }

            speak(text, options = {}) {
                if (!this.isInitialized) {
                    console.warn('Voice synthesis not initialized');
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = this.voice;
                utterance.rate = options.rate || this.settings.rate;
                utterance.pitch = options.pitch || this.settings.pitch;
                utterance.volume = options.volume || this.settings.volume;

                // Add some personality to Rina's voice
                if (text.includes('üßú‚Äç‚ôÄÔ∏è') || text.includes('mermaid')) {
                    utterance.pitch = 1.2;
                    utterance.rate = 0.9;
                }

                this.synth.speak(utterance);
                return utterance;
            }

            stop() {
                this.synth.cancel();
            }

            setVoice(voiceName) {
                const voices = this.synth.getVoices();
                this.voice = voices.find(v => v.name === voiceName) || this.voice;
            }

            getVoices() {
                return this.synth.getVoices();
            }
        }

        // AI Assistant with Voice Integration
        class VoiceEnabledAI {
            constructor(speechEngine, voiceEngine) {
                this.speechEngine = speechEngine;
                this.voiceEngine = voiceEngine;
                this.isVoiceMode = false;
                this.conversationHistory = [];
            }

            async processCommand(command, confidence = 1.0) {
                console.log('Processing AI command:', command, 'Confidence:', confidence);
                
                // Add to conversation history
                this.conversationHistory.push({
                    type: 'user',
                    text: command,
                    confidence: confidence,
                    timestamp: new Date().toISOString()
                });

                let response;
                let shouldSpeak = true;
                let match = null; // Initialize match variable

                try {
                    // Check if advanced AI is available
                    if (window.aiManager && window.aiManager.isInitialized) {
                        const aiResult = await window.aiManager.processUserCommand(command, {
                            timestamp: new Date().toISOString(),
                            sessionId: window.aiManager.sessionId,
                            voiceMode: this.isVoiceMode,
                            confidence: confidence
                        });
                        response = aiResult.response;
                    } else {
                        // Use enhanced pattern matching
                        match = findBestMatch(command);
                        if (match) {
                            response = `Executing: ${match.command}`;
                            // Execute the command if shell harness is available
                            if (shellHarness) {
                                try {
                                    await shellHarness.execute(match.command);
                                    terminal.write(`\r\nüßú‚Äç‚ôÄÔ∏è Voice Command: ${match.command}\r\n`);
                                } catch (execError) {
                                    console.error('Voice command execution failed:', execError);
                                }
                            }
                        } else {
                            response = `Sorry, I didn't understand "${command}". Try commands like "list files" or "git status".`;
                        }
                    }

                    // Add response to history
                    this.conversationHistory.push({
                        type: 'assistant',
                        text: response,
                        timestamp: new Date().toISOString()
                    });

                    // Speak the response if voice mode is active
                    if (this.isVoiceMode && shouldSpeak && this.voiceEngine) {
                        // Clean response for speech (remove emojis and markdown)
                        const cleanResponse = response
                            .replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄ]/g, '')
                            .replace(/\*([^*]+)\*/g, '$1')
                            .replace(/`([^`]+)`/g, '$1')
                            .trim();
                        
                        this.voiceEngine.speak(cleanResponse);
                    }

                    return {
                        response: response,
                        confidence: confidence,
                        executed: !!match
                    };

                } catch (error) {
                    console.error('AI processing error:', error);
                    const errorResponse = `Sorry, I encountered an error: ${error.message}`;
                    
                    if (this.isVoiceMode && this.voiceEngine) {
                        this.voiceEngine.speak(errorResponse);
                    }
                    
                    return {
                        response: errorResponse,
                        confidence: 0,
                        error: error.message
                    };
                }
            }

            enableVoiceMode() {
                this.isVoiceMode = true;
                if (this.voiceEngine) {
                    this.voiceEngine.speak('Voice mode enabled. I\'m listening for your commands.');
                }
            }

            disableVoiceMode() {
                this.isVoiceMode = false;
                if (this.voiceEngine) {
                    this.voiceEngine.speak('Voice mode disabled.');
                }
            }
        }

        // Initialize Advanced Voice Systems
        async function initVoiceSystems() {
            try {
                console.log('üé§ Initializing Advanced Voice Recognition System...');
                
                // Initialize Rina's personality engine (if available)
                if (window.RinaPersonalityEngine) {
                    rinaPersonality = new RinaPersonalityEngine();
                    console.log('üßú‚Äç‚ôÄÔ∏è Rina\'s personality engine initialized!');
                } else {
                    console.log('üßú‚Äç‚ôÄÔ∏è Rina\'s personality engine not available, using fallback');
                    rinaPersonality = {
                        mood: 'happy',
                        handleSpecialTrigger: () => null,
                        generateResponse: (command, result) => ({ ...result, mood: 'happy', suggestions: [] })
                    };
                }
                
                // Initialize Rina's advanced dialogue system (if available)
                if (window.RinaDialogueSystem) {
                    rinaDialogue = new RinaDialogueSystem();
                    console.log('üßú‚Äç‚ôÄÔ∏è Rina\'s dialogue system initialized!');
                } else {
                    console.log('üßú‚Äç‚ôÄÔ∏è Rina\'s dialogue system not available, using fallback');
                    rinaDialogue = {
                        generateResponse: (context, response) => response
                    };
                }
                
                // Import and initialize the advanced voice recognition system
                let AdvancedVoiceRecognition;
                try {
                    const voiceModule = await import('./voice-recognition-advanced.js');
                    AdvancedVoiceRecognition = voiceModule.AdvancedVoiceRecognition || voiceModule.default;
                } catch (error) {
                    console.warn('Advanced voice recognition not available, using fallback:', error);
                    // Create a fallback voice recognition system
                    AdvancedVoiceRecognition = class {
                        constructor() {
                            this.isListening = false;
                            this.onCommand = null;
                            this.onStatusChange = null;
                        }
                        async init() { 
                            if (this.onStatusChange) this.onStatusChange('initialized', { provider: 'keyboard' });
                            return true; 
                        }
                        async start() { 
                            this.isListening = true;
                            if (this.onStatusChange) this.onStatusChange('listening');
                        }
                        async stop() { 
                            this.isListening = false;
                            if (this.onStatusChange) this.onStatusChange('stopped');
                        }
                        getProviderInfo() { return { current: 'fallback' }; }
                    };
                }
                
                advancedVoiceRecognition = new AdvancedVoiceRecognition();
                
                // Make sure we use the enhanced keyboard provider
                if (window.EnhancedKeyboardProvider) {
                    console.log('Using enhanced keyboard provider for better UX');
                }
                
                // Initialize voice synthesis for responses
                voiceEngine = new VoiceSynthesisEngine();
                await voiceEngine.init();
                
                // Store voice engine in terminalState
                window.terminalState.voiceEngine = voiceEngine;
                window.terminalState.advancedVoiceRecognition = advancedVoiceRecognition;
                
                // Initialize AI assistant with voice
                aiAssistant = new VoiceEnabledAI(advancedVoiceRecognition, voiceEngine);
                
                // Expose to global scope for voice control function
                window.aiAssistant = aiAssistant;
                
                // Set up event handlers for the advanced voice recognition
                advancedVoiceRecognition.onCommand = async (command, confidence) => {
                    console.log('üé§ Voice command received:', command);
                    document.getElementById('aiInput').value = command;
                    
                    // Check for special personality triggers first
                    const specialTrigger = rinaPersonality.handleSpecialTrigger(command);
                    if (specialTrigger) {
                        const responseDiv = document.getElementById('aiResponse');
                        responseDiv.innerHTML = `
                            <div style="color: #FF1493; font-weight: bold;">${specialTrigger.response}</div>
                            <div style="color: #8A2BE2; font-size: 12px; margin-top: 5px;">
                                Mood: ${specialTrigger.mood || rinaPersonality.mood} | Special Command
                            </div>
                        `;
                        
                        // Speak the response
                        if (voiceEngine) {
                            const cleanResponse = specialTrigger.response.replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄ]/g, '').replace(/\*([^*]+)\*/g, '$1');
                            voiceEngine.speak(cleanResponse);
                        }
                        return;
                    }
                    
                    // Process regular command
                    const result = await aiAssistant.processCommand(command, confidence);
                    
                    // Let Rina add her personality to the response
                    const personalizedResult = rinaPersonality.generateResponse(command, result, { confidence });
                    
                    // Enhance with advanced dialogue system for more contextual responses
                    if (rinaDialogue) {
                        const isSuccess = !result.error && result.executed;
                        const isError = !!result.error;
                        const dialogueContext = {
                            type: isError ? 'error' : (isSuccess ? 'success' : 'greeting'),
                            success: isSuccess,
                            isError: isError,
                            mood: personalizedResult.mood,
                            confidence: confidence || 0.8
                        };
                        
                        // Generate enhanced response using dialogue system
                        const enhancedResponse = rinaDialogue.generateResponse(dialogueContext, personalizedResult.response);
                        personalizedResult.response = enhancedResponse;
                    }
                    
                    // Update UI with provider info and personality
                    const providerInfo = advancedVoiceRecognition.getProviderInfo();
                    const responseDiv = document.getElementById('aiResponse');
                    responseDiv.innerHTML = `
                        <div style="color: #FF1493; font-weight: bold;">${personalizedResult.response}</div>
                        <div style="color: #00AAFF; font-size: 12px; margin-top: 5px;">
                            Provider: ${providerInfo.current} | Confidence: ${Math.round((confidence || 0) * 100)}% | Mood: ${personalizedResult.mood}
                        </div>
                        ${personalizedResult.suggestions.length > 0 ? 
                            `<div style="color: #00FF88; font-size: 11px; margin-top: 5px;">
                                üí° ${personalizedResult.suggestions.join(' ‚Ä¢ ')}
                            </div>` : ''}
                    `;
                    
                    // Speak the personalized response
                    if (voiceEngine && aiAssistant.isVoiceMode) {
                        const cleanResponse = personalizedResult.response.replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄ]/g, '').replace(/\*([^*]+)\*/g, '$1');
                        voiceEngine.speak(cleanResponse);
                    }
                    
                    // Visual feedback for voice command
                    responseDiv.style.border = '2px solid #00ff88';
                    setTimeout(() => {
                        responseDiv.style.border = 'none';
                    }, 1500);
                };
                
                advancedVoiceRecognition.onStatusChange = (status, data) => {
                    const indicator = document.getElementById('voiceIndicator');
                    
                    switch (status) {
                        case 'initialized':
                            const providerName = data.provider === 'keyboard' ? 'Keyboard' : 
                                                data.provider === 'webspeech' ? 'Web Speech' : 
                                                data.provider === 'vosk' ? 'Vosk (Offline)' : data.provider;
                            updateStatus(`‚úÖ Voice recognition ready using ${providerName} provider`);
                            
                            // Update button text based on provider
                            const voiceButton = document.querySelector('button[onclick="startVoiceControl()"]');
                            if (voiceButton) {
                                if (data.provider === 'keyboard') {
                                    voiceButton.innerHTML = '‚å®Ô∏è Voice (Keyboard) <span class="voice-indicator" id="voiceIndicator"></span>';
                                    voiceButton.title = 'Press Ctrl+Shift+V for voice command input';
                                } else {
                                    voiceButton.innerHTML = 'üé§ Voice Control <span class="voice-indicator" id="voiceIndicator"></span>';
                                    voiceButton.title = 'Click to start/stop voice recognition';
                                }
                            }
                            break;
                            
                        case 'provider-switched':
                            const fromProvider = data.from === 'keyboard' ? 'Keyboard' : 
                                               data.from === 'webspeech' ? 'Web Speech' : 
                                               data.from === 'vosk' ? 'Vosk' : data.from;
                            const toProvider = data.to === 'keyboard' ? 'Keyboard' : 
                                             data.to === 'webspeech' ? 'Web Speech' : 
                                             data.to === 'vosk' ? 'Vosk' : data.to;
                            updateStatus(`üîÑ Voice provider switched from ${fromProvider} to ${toProvider}`);
                            
                            // Show user notification
                            if (data.to === 'keyboard') {
                                alert('üé§‚û°Ô∏è‚å®Ô∏è Voice recognition switched to keyboard mode due to connection issues.\n\nUse Ctrl+Shift+V to input voice commands via keyboard.');
                            }
                            break;
                            
                        case 'listening':
                            indicator.classList.add('active');
                            updateStatus('üé§ Voice control active - say "Hey Rina" followed by your command');
                            break;
                            
                        case 'stopped':
                            indicator.classList.remove('active');
                            updateStatus('üé§ Voice control stopped');
                            break;
                            
                        case 'error':
                            indicator.classList.remove('active');
                            updateStatus(`‚ùå Voice error: ${data || 'Unknown error'}`);
                            break;
                    }
                };
                
                // Initialize the advanced voice recognition system
                await advancedVoiceRecognition.init();
                
                console.log('‚úÖ Advanced Voice Recognition System initialized successfully');
                return true;
                
            } catch (error) {
                console.error('Failed to initialize voice systems:', error);
                updateStatus(`‚ùå Voice systems unavailable: ${error.message}`);
                return false;
            }
        }

        // Load AI Integration
        async function loadAIIntegration() {
            try {
                const { AIIntegrationManager } = await import('./ai-integration.js');
                window.aiManager = new AIIntegrationManager();
                console.log('üßú‚Äç‚ôÄÔ∏è AI Integration loaded successfully!');
            } catch (error) {
                console.warn('AI Integration not available:', error);
                // Set up basic fallback
                window.processAICommand = async (command) => {
                    return {
                        response: 'üßú‚Äç‚ôÄÔ∏è Basic mermaid AI: ' + command,
                        suggestions: []
                    };
                };
            }
        }
        
        // Load Enhanced AI System with Unified Intelligence
        async function loadEnhancedAI() {
            try {
                console.log('üöÄ Loading RinaWarp Unified AI System...');
                
                // Initialize the Unified AI System
                const config = {
                    enableExternalLLM: true,
                    enableLearning: true,
                    hybridMode: true,
                    llmConfig: {
                        provider: 'auto', // Will auto-detect best available provider
                        // API keys can be set later through configuration
                        maxTokens: 512,
                        temperature: 0.7
                    },
                    learningConfig: {
                        adaptationRate: 0.1,
                        forgettingFactor: 0.95
                    }
                };
                
                // Import and create the unified AI system
                let UnifiedAISystem;
                try {
                    const aiModule = await import('./ai-system/unified-ai-system.js');
                    UnifiedAISystem = aiModule.UnifiedAISystem || aiModule.default;
                } catch (error) {
                    console.warn('UnifiedAISystem not available, using fallback:', error);
                    // Create a fallback AI system
                    UnifiedAISystem = class {
                        constructor(config) { this.config = config; }
                        async initialize() { return true; }
                        getSystemStatus() { return { initialized: false, currentMode: 'fallback' }; }
                        async processCommand(input) {
                            return {
                                response: `üßú‚Äç‚ôÄÔ∏è Basic AI: I heard "${input}" but enhanced features are not available.`,
                                confidence: 0.5,
                                source: 'fallback'
                            };
                        }
                    };
                }
                
                window.rinaWarpAI = new UnifiedAISystem(config);
                const initialized = await window.rinaWarpAI.initialize();
                
                if (initialized) {
                    const status = window.rinaWarpAI.getSystemStatus();
                    console.log(`‚úÖ Unified AI System initialized in ${status.currentMode} mode`);
                    updateStatus(`üß† AI Enhanced: ${status.currentMode} mode (${status.llmAvailable ? 'LLM+' : ''}${status.learningEnabled ? 'Learning' : 'Local'})`);
                } else {
                    console.warn('‚ö†Ô∏è Unified AI System initialization failed, falling back to basic mode');
                    updateStatus('‚ö†Ô∏è Basic AI mode (Enhanced features unavailable)');
                }
                
                // Also try to load the legacy enhancement system as backup
                try {
                    const script = document.createElement('script');
                    script.src = './renderer/ai-integration-loader.js';
                    script.type = 'text/javascript';
                    document.head.appendChild(script);
                    console.log('üì¶ Legacy AI enhancement system loaded as backup');
                } catch (legacyError) {
                    console.warn('Legacy AI system not available:', legacyError);
                }
                
            } catch (error) {
                console.error('Failed to load enhanced AI system:', error);
                updateStatus('‚ùå AI enhancement failed - using basic mode');
            }
        }
        
        // Initialize AI Configuration Interface
        // Alias function for the button
        function showAIConfig() {
            showAIConfiguration();
        }
        
        async function showAIConfiguration() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; align-items: center;
                justify-content: center; z-index: 1000;
            `;
            
            const systemStatus = window.rinaWarpAI ? window.rinaWarpAI.getSystemStatus() : null;
            
            modal.innerHTML = `
                <div style="
                    background: #2d2d2d; padding: 30px; border-radius: 10px;
                    max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto;
                    border: 2px solid #555;
                ">
                    <h2 style="color: #00ff88; margin-top: 0;">üß† AI System Configuration</h2>
                    
                    ${systemStatus ? `
                        <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <h3 style="color: #74c0fc; margin-top: 0;">System Status</h3>
                            <p><strong>Mode:</strong> ${systemStatus.currentMode}</p>
                            <p><strong>LLM Available:</strong> ${systemStatus.llmAvailable ? '‚úÖ Yes' : '‚ùå No'}</p>
                            <p><strong>Learning Enabled:</strong> ${systemStatus.learningEnabled ? '‚úÖ Yes' : '‚ùå No'}</p>
                            <p><strong>Total Requests:</strong> ${systemStatus.performanceMetrics?.totalRequests || 0}</p>
                            <p><strong>Success Rate:</strong> ${systemStatus.performanceMetrics ? Math.round((systemStatus.performanceMetrics.successfulRequests / Math.max(systemStatus.performanceMetrics.totalRequests, 1)) * 100) : 0}%</p>
                        </div>
                    ` : '<p style="color: #ff6b6b;">Unified AI System not available</p>'}
                    
                    <div style="margin: 20px 0;">
                        <h3 style="color: #ffd93d;">External LLM Configuration</h3>
                        <div style="margin: 10px 0;">
                            <label style="color: #fff; display: block; margin-bottom: 5px;">Provider:</label>
                            <select id="llmProvider" style="width: 100%; padding: 8px; background: #444; color: white; border: 1px solid #666; border-radius: 4px;">
                                <option value="auto">Auto-detect</option>
                                <option value="openai">OpenAI (GPT-4)</option>
                                <option value="anthropic">Anthropic (Claude)</option>
                                <option value="google">Google (Gemini)</option>
                                <option value="ollama">Ollama (Local)</option>
                            </select>
                        </div>
                        <div style="margin: 10px 0;">
                            <label style="color: #fff; display: block; margin-bottom: 5px;">API Key:</label>
                            <input type="password" id="llmApiKey" placeholder="Enter API key (leave blank for local providers)" 
                                   style="width: 100%; padding: 8px; background: #444; color: white; border: 1px solid #666; border-radius: 4px;">
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="saveLLMConfig()" 
                                style="padding: 10px 20px; background: #007acc; color: white; 
                                       border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">Save LLM Config</button>
                        <button onclick="testLLMConnection()" 
                                style="padding: 10px 20px; background: #28a745; color: white; 
                                       border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">Test Connection</button>
                        <button onclick="switchAIMode()" 
                                style="padding: 10px 20px; background: #ffd93d; color: #333; 
                                       border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">Switch Mode</button>
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                                style="padding: 10px 20px; background: #999; color: white; 
                                       border: none; border-radius: 5px; cursor: pointer;">Close</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        async function saveLLMConfig() {
            const provider = document.getElementById('llmProvider').value;
            const apiKey = document.getElementById('llmApiKey').value.trim();
            
            if (window.rinaWarpAI) {
                try {
                    // Update LLM client configuration
                    if (window.rinaWarpAI.llmClient) {
                        window.rinaWarpAI.llmClient.updateConfig({ provider, apiKey });
                        await window.rinaWarpAI.llmClient.initialize();
                    }
                    
                    updateStatus('‚úÖ LLM configuration updated successfully');
                    alert('‚úÖ LLM configuration saved and applied!');
                } catch (error) {
                    updateStatus('‚ùå Failed to update LLM configuration');
                    alert(`‚ùå Configuration failed: ${error.message}`);
                }
            } else {
                alert('‚ùå Unified AI System not available');
            }
        }
        
        async function testLLMConnection() {
            if (window.rinaWarpAI && window.rinaWarpAI.llmClient) {
                try {
                    updateStatus('üß† Testing LLM connection...');
                    const response = await window.rinaWarpAI.llmClient.generateResponse('Reply with "Connection successful" if you can read this.', { maxTokens: 10 });
                    
                    if (response.toLowerCase().includes('successful') || response.toLowerCase().includes('ok')) {
                        updateStatus('‚úÖ LLM connection test successful!');
                        alert('‚úÖ LLM connection is working!');
                    } else {
                        updateStatus('‚ö†Ô∏è LLM responded but may not be working correctly');
                        alert(`‚ö†Ô∏è Unexpected response: ${response}`);
                    }
                } catch (error) {
                    updateStatus('‚ùå LLM connection test failed');
                    alert(`‚ùå Connection failed: ${error.message}`);
                }
            } else {
                alert('‚ùå LLM client not available');
            }
        }
        
        async function switchAIMode() {
            if (window.rinaWarpAI) {
                const currentMode = window.rinaWarpAI.systemState.currentMode;
                const modes = ['hybrid', 'llm', 'learning', 'local'];
                const currentIndex = modes.indexOf(currentMode);
                const nextMode = modes[(currentIndex + 1) % modes.length];
                
                const success = window.rinaWarpAI.switchMode(nextMode);
                if (success) {
                    updateStatus(`üîÑ Switched to ${nextMode} mode`);
                    alert(`üîÑ AI mode switched to: ${nextMode}`);
                } else {
                    alert('‚ùå Failed to switch AI mode');
                }
            } else {
                alert('‚ùå Unified AI System not available');
            }
        }
        
        // Add button to controls for AI configuration
        document.addEventListener('DOMContentLoaded', () => {
            const controls = document.querySelector('.controls');
            if (controls) {
                const aiConfigButton = document.createElement('button');
                aiConfigButton.onclick = showAIConfiguration;
                aiConfigButton.innerHTML = 'üß† AI Config';
                controls.appendChild(aiConfigButton);
            }
        });
        
        // ElevenLabs Conversational AI Integration
        async function startConversationalAI() {
            try {
                if (!elevenLabsAgent) {
                    // Load ElevenLabs configuration
                    const config = await window.electronAPI.loadElevenLabsConfig();
                    
                    if (!config.apiKey) {
                        alert('Please configure ElevenLabs API key first!');
                        configureElevenLabs();
                        return;
                    }
                    
                    // Initialize the agent - use the global ElevenLabsAgentIntegration object
                    if (window.ElevenLabsAgentIntegration) {
                        elevenLabsAgent = window.ElevenLabsAgentIntegration;
                        await elevenLabsAgent.updateConfig(config.apiKey, config.voiceId || 'EXAVITQu4vr4xnSDxMaL');
                    } else {
                        throw new Error('ElevenLabs Agent Integration not loaded');
                    }
                    
                    // Set up event handlers
                    elevenLabsAgent.onTranscript = (text, speaker) => {
                        if (speaker === 'user') {
                            document.getElementById('aiInput').value = text;
                        }
                        console.log(`üí¨ ${speaker}: ${text}`);
                    };
                    
                    elevenLabsAgent.onResponse = async (text, data) => {
                        const responseDiv = document.getElementById('aiResponse');
                        responseDiv.innerHTML = `
                            <div style="color: #FF1493; font-weight: bold;">üó£Ô∏è ${text}</div>
                            <div style="color: #00AAFF; font-size: 12px; margin-top: 5px;">
                                üéØ ElevenLabs Conversational AI Agent
                            </div>
                        `;
                        
                        // If the agent calls for terminal execution
                        if (data.functionCall) {
                            terminal.write(`\r\nü§ñ AI Agent: Executing ${data.functionCall}\r\n`);
                        }
                    };
                    
                    elevenLabsAgent.onError = (error) => {
                        console.error('ElevenLabs Agent error:', error);
                        updateStatus(`‚ùå Conversational AI error: ${error.message}`);
                    };
                    
                    elevenLabsAgent.onStatusChange = (status, data) => {
                        switch (status) {
                            case 'initialized':
                                updateStatus('‚úÖ ElevenLabs Agent initialized');
                                break;
                            case 'conversation-started':
                                updateStatus('üó£Ô∏è Conversational AI active - speak naturally!');
                                isConversationalAIActive = true;
                                document.getElementById('conversationalAIBtn').textContent = 'üó£Ô∏è AI Conversation: ON';
                                break;
                            case 'conversation-ended':
                                updateStatus('üîö Conversational AI ended');
                                isConversationalAIActive = false;
                                document.getElementById('conversationalAIBtn').textContent = 'üó£Ô∏è AI Conversation: OFF';
                                break;
                        }
                    };
                    
                    // Initialize the agent
                    const initialized = await elevenLabsAgent.initialize();
                    if (!initialized) {
                        throw new Error('Failed to initialize ElevenLabs agent');
                    }
                }
                
                // Toggle conversation
                if (!isConversationalAIActive) {
                    await elevenLabsAgent.startConversation();
                } else {
                    await elevenLabsAgent.endConversation();
                }
                
            } catch (error) {
                console.error('Failed to start conversational AI:', error);
                alert(`Failed to start conversational AI: ${error.message}`);
            }
        }
        
        // Initialize all new terminal features
        async function initializeNewFeatures() {
            try {
                console.log('üöÄ Initializing new terminal features...');
                
                // Initialize AutoComplete System
                try {
                    const { AutoCompleteSystem } = await import('./renderer/autocomplete-system.js');
                    window.autoCompleteSystem = new AutoCompleteSystem(terminal);
                    console.log('‚úÖ AutoComplete System initialized');
                } catch (error) {
                    console.warn('AutoComplete System not available:', error);
                }
                
                // Initialize Syntax Highlighter
                try {
                    const { SyntaxHighlighter } = await import('./renderer/syntax-highlighter.js');
                    window.syntaxHighlighter = new SyntaxHighlighter();
                    console.log('‚úÖ Syntax Highlighter initialized');
                } catch (error) {
                    console.warn('Syntax Highlighter not available:', error);
                }
                
                // Initialize Command History
                try {
                    const { CommandHistory } = await import('./renderer/command-history.js');
                    window.commandHistory = new CommandHistory();
                    console.log('‚úÖ Command History initialized');
                } catch (error) {
                    console.warn('Command History not available:', error);
                }
                
                // Initialize Terminal Themes
                try {
                    const { TerminalThemes } = await import('./renderer/terminal-themes.js');
                    window.terminalThemes = new TerminalThemes(terminal);
                    // Apply saved theme if available
                    const savedTheme = localStorage.getItem('terminal-theme');
                    if (savedTheme) {
                        window.terminalThemes.applyTheme(savedTheme);
                    }
                    console.log('‚úÖ Terminal Themes initialized');
                } catch (error) {
                    console.warn('Terminal Themes not available:', error);
                }
                
                // Initialize Cloud Sync
                try {
                    const { CloudSync } = await import('./renderer/cloud-sync.js');
                    window.cloudSync = new CloudSync();
                    console.log('‚úÖ Cloud Sync initialized');
                } catch (error) {
                    console.warn('Cloud Sync not available:', error);
                }
                
                // Initialize Plugin System
                try {
                    const { PluginSystem } = await import('./renderer/plugin-system.js');
                    window.pluginSystem = new PluginSystem();
                    await window.pluginSystem.loadPlugins();
                    console.log('‚úÖ Plugin System initialized');
                } catch (error) {
                    console.warn('Plugin System not available:', error);
                }
                
                // Initialize Split Pane
                try {
                    const { SplitPane } = await import('./renderer/split-pane.js');
                    window.splitPane = new SplitPane(terminal);
                    console.log('‚úÖ Split Pane initialized');
                } catch (error) {
                    console.warn('Split Pane not available:', error);
                }
                
                // Initialize Enhanced Error Handler
                try {
                    const { ErrorHandler } = await import('./renderer/error-handler.js');
                    window.errorHandler = new ErrorHandler();
                    window.errorHandler.initialize();
                    console.log('‚úÖ Enhanced Error Handler initialized');
                } catch (error) {
                    console.warn('Enhanced Error Handler not available:', error);
                }
                
                // Initialize Settings Panel (if not already initialized)
                if (!window.settingsPanel) {
                    try {
                        const { SettingsPanel } = await import('./renderer/settings-panel.js');
                        window.settingsPanel = new SettingsPanel();
                        console.log('‚úÖ Settings Panel initialized');
                    } catch (error) {
                        console.warn('Settings Panel not available:', error);
                    }
                }
                
                // Initialize Enhanced Voice AI Integration
                try {
                    const VoiceAIModule = await import('./voice-ai-integration.js');
                    const { VoiceAIIntegration } = VoiceAIModule;
                    
                    // Replace/enhance existing voice system with our new AI-powered one
                    window.voiceAI = new VoiceAIIntegration();
                    
                    // Hook into existing voice control button
                    const voiceBtn = document.getElementById('voiceControlBtn');
                    if (voiceBtn) {
                        voiceBtn.onclick = () => window.voiceAI.toggleVoiceRecognition();
                        voiceBtn.title = 'Voice AI (Ctrl+Shift+V) - Say "Hey Rina" + command';
                    }
                    
                    console.log('‚úÖ Enhanced Voice AI Integration initialized');
                    updateStatus('üé§ Voice AI ready - say "Hey Rina" to start');
                    
                } catch (error) {
                    console.warn('Voice AI Integration not available:', error);
                    updateStatus('‚ö†Ô∏è Voice AI unavailable - check console for details');
                }
                
                updateStatus('‚úÖ All terminal features initialized successfully');
                
            } catch (error) {
                console.error('Error initializing terminal features:', error);
                updateStatus('‚ö†Ô∏è Some features may not be available');
            }
        }
        
        // Sidebar toggle functionality
        function toggleSidebar() {
            const sidebar = document.getElementById('featuresSidebar');
            const toggleBtn = sidebar.querySelector('.sidebar-toggle');
            
            sidebar.classList.toggle('collapsed');
            
            if (sidebar.classList.contains('collapsed')) {
                toggleBtn.textContent = '‚Üí';
                toggleBtn.title = 'Expand Features Panel';
            } else {
                toggleBtn.textContent = '‚Üê';
                toggleBtn.title = 'Collapse Features Panel';
            }
        }
        
        // AI Chat overlay functions
        function showAIChat() {
            document.getElementById('aiChatOverlay').style.display = 'flex';
            
            // Focus on the input
            setTimeout(() => {
                document.getElementById('aiChatInput').focus();
            }, 100);
        }
        
        function hideAIChat() {
            document.getElementById('aiChatOverlay').style.display = 'none';
        }
        
        async function sendAIMessage() {
            const input = document.getElementById('aiChatInput');
            const messagesContainer = document.getElementById('aiChatMessages');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            const userMessage = document.createElement('div');
            userMessage.className = 'user-message';
            userMessage.innerHTML = `üë§ ${message}`;
            messagesContainer.appendChild(userMessage);
            
            // Clear input
            input.value = '';
            
            // Show typing indicator
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'ai-message';
            typingIndicator.innerHTML = 'üßú‚Äç‚ôÄÔ∏è <em>*thinking...*</em>';
            messagesContainer.appendChild(typingIndicator);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            try {
                let response;
                
                // Use enhanced AI system if available
                if (window.rinaWarpAI && window.rinaWarpAI.getSystemStatus().initialized) {
                    const result = await window.rinaWarpAI.processCommand(message);
                    response = result.response || result.message;
                } else if (window.aiManager && window.aiManager.isInitialized) {
                    const aiResult = await window.aiManager.processUserCommand(message, {
                        timestamp: new Date().toISOString(),
                        sessionId: window.aiManager.sessionId
                    });
                    response = aiResult.response;
                } else {
                    // Legacy mode - find matching command
                    const match = findBestMatch(message);
                    if (match) {
                        response = `üßú‚Äç‚ôÄÔ∏è I understand! "${match.phrase}" ‚Üí <code>${match.command}</code>`;
                        
                        // Execute command if shell harness is available
                        if (shellHarness) {
                            try {
                                await shellHarness.execute(match.command);
                                terminal.write(`\r\nüí¨ Chat Command: ${match.command}\r\n`);
                            } catch (execError) {
                                response += `<br>‚ùå Execution failed: ${execError.message}`;
                            }
                        }
                    } else {
                        response = `üßú‚Äç‚ôÄÔ∏è <em>*adjusts seashell crown*</em> I'm not sure about "${message}". Try asking about files, git, npm, or system info!`;
                    }
                }
                
                // Remove typing indicator
                messagesContainer.removeChild(typingIndicator);
                
                // Add AI response
                const aiMessage = document.createElement('div');
                aiMessage.className = 'ai-message';
                aiMessage.innerHTML = response;
                messagesContainer.appendChild(aiMessage);
                
                // Add some mermaid flair
                if (!response.includes('not sure') && !response.includes('adjusts seashell')) {
                    const emojis = ['üåä', 'üêö', 'üêô', 'üê≥', 'üå∫', '‚ú®'];
                    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
                    const flairMessage = document.createElement('div');
                    flairMessage.className = 'ai-message';
                    flairMessage.innerHTML = `<em style="opacity: 0.7; text-align: right;">${randomEmoji}</em>`;
                    messagesContainer.appendChild(flairMessage);
                }
                
                // Speak response if voice output is enabled
                if (isVoiceOutputEnabled && voiceEngine && voiceEngine.isInitialized) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = response;
                    const textToSpeak = tempDiv.textContent || tempDiv.innerText || '';
                    const cleanText = textToSpeak.replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄ]/g, '').replace(/\s+/g, ' ').trim();
                    if (cleanText && cleanText.length > 5) {
                        voiceEngine.speak(cleanText);
                    }
                }
                
            } catch (error) {
                // Remove typing indicator
                if (messagesContainer.contains(typingIndicator)) {
                    messagesContainer.removeChild(typingIndicator);
                }
                
                // Show error
                const errorMessage = document.createElement('div');
                errorMessage.className = 'ai-message';
                errorMessage.innerHTML = `üßú‚Äç‚ôÄÔ∏è <em>*bubbles of confusion*</em> Sorry, I encountered an error: ${error.message}`;
                messagesContainer.appendChild(errorMessage);
            }
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Handle Enter key in AI chat
        document.addEventListener('DOMContentLoaded', () => {
            const aiChatInput = document.getElementById('aiChatInput');
            if (aiChatInput) {
                aiChatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendAIMessage();
                    }
                });
            }
        });
        
        // Sidebar feature placeholder functions (to be implemented)
        function startCodeGeneration() {
            alert('üßú‚Äç‚ôÄÔ∏è Code generation is coming soon in the next update! Stay tuned for AI-powered coding assistance.');
        }
        
        function startDebugging() {
            alert('üßú‚Äç‚ôÄÔ∏è Smart debugging tools are under development! Soon you\'ll have AI-powered debugging assistance.');
        }
        
        function startArchAnalysis() {
            alert('üßú‚Äç‚ôÄÔ∏è Architecture analysis will be available soon! I\'ll help you understand and optimize your codebase.');
        }
        
        function enableVoiceOutput() {
            toggleVoiceOutput();
        }
        
        function customizeVoice() {
            alert('üßú‚Äç‚ôÄÔ∏è Voice customization settings are coming! You\'ll be able to adjust my voice and personality.');
        }
        
        function openCloudSync() {
            alert('üßú‚Äç‚ôÄÔ∏è Cloud sync features are in development! Soon you\'ll sync your terminal sessions across devices.');
        }
        
        function manageBackups() {
            alert('üßú‚Äç‚ôÄÔ∏è Backup management is coming soon! I\'ll help you keep your configurations safe.');
        }
        
        function shareSession() {
            alert('üßú‚Äç‚ôÄÔ∏è Session sharing features are being developed! Soon you can collaborate with your team.');
        }
        
        function startCollaboration() {
            alert('üßú‚Äç‚ôÄÔ∏è Real-time collaboration tools are coming! Work together with your team seamlessly.');
        }
        
        function openSecurityPanel() {
            alert('üßú‚Äç‚ôÄÔ∏è Security management panel is under development! Enhanced security features coming soon.');
        }
        
        function managePermissions() {
            alert('üßú‚Äç‚ôÄÔ∏è Permission management system is coming! Fine-grained control over access and features.');
        }
        
        // Load AI and Voice Systems on page ready
        document.addEventListener('DOMContentLoaded', async () => {
            await loadAIIntegration();
            await initVoiceSystems();
            await loadEnhancedAI(); // Load the new unified AI system
            
            // Enable AI Assistant and Agent Mode by default
            window.aiAssistantEnabled = true;
            window.agentModeEnabled = true;
            updateStatus('‚úÖ AI Assistant and Agent Mode enabled by default');
            
            // Apply settings from settings panel if available
            window.addEventListener('setting-changed', (event) => {
                const { setting, value } = event.detail;
                console.log(`Setting changed: ${setting} = ${value}`);
            });
            
            // Initialize new terminal features
            await initializeNewFeatures();
        });
    </script>
</body>
</html>
