<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <!-- CSP Updated 2025-07-12 for enhanced security -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; connect-src 'self' ws: wss:; media-src 'self' blob:;">
    <title>RinaWarp Terminal - AI-Powered Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #008B8B 0%, #FF1493 50%, #00AAFF 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
            position: relative;
            padding: 20px;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 20, 147, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 139, 139, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(0, 170, 255, 0.15) 0%, transparent 50%);
            animation: waveRipple 20s ease-in-out infinite;
            z-index: -1;
        }
        
        .header {
            background: rgba(0, 139, 139, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 20, 147, 0.3);
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="%23FF1493" opacity="0.05"/><circle cx="80" cy="80" r="3" fill="%23008B8B" opacity="0.05"/><circle cx="50" cy="30" r="1.5" fill="%2300AAFF" opacity="0.05"/></svg>') repeat;
            animation: particleFloat 30s linear infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        .header h1 {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #FF1493, #00AAFF, #8A2BE2, #FF1493);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: logoWave 8s ease-in-out infinite;
        }
        
        .status {
            margin: 10px 0;
            padding: 15px;
            background: rgba(255, 20, 147, 0.1);
            border: 1px solid rgba(255, 20, 147, 0.3);
            border-radius: 15px;
            text-align: center;
            color: #FF1493;
            text-shadow: 0 0 10px rgba(255, 20, 147, 0.5);
            font-weight: bold;
        }
        
        .terminal-container {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 170, 255, 0.3);
            border-radius: 20px;
            height: 500px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 30px rgba(0, 170, 255, 0.3);
        }
        
        #terminal {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #FF1493, #00AAFF, #8A2BE2);
            background-size: 200% 200%;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: pearlShimmer 4s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: underwaterCurrent 3s ease-in-out infinite;
        }
        
        button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 20, 147, 0.5);
        }
        
        .ai-section {
            background: rgba(0, 139, 139, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 20, 147, 0.3);
            margin: 30px 0;
            padding: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .ai-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="%23FF1493" opacity="0.05"/><circle cx="80" cy="80" r="3" fill="%23008B8B" opacity="0.05"/><circle cx="50" cy="30" r="1.5" fill="%2300AAFF" opacity="0.05"/></svg>') repeat;
            animation: particleFloat 30s linear infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        input[type="text"] {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 2px solid rgba(255, 20, 147, 0.3);
            padding: 15px;
            margin: 10px 5px 10px 0;
            border-radius: 15px;
            width: 400px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #FF1493;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.5);
            transform: scale(1.02);
        }
        
        .voice-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #ff4444;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 1s infinite;
        }
        
        .voice-indicator.active {
            background: #00ff88;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .feature-card {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #555;
            text-align: center;
        }
        
        .version-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #888;
        }
        
        /* Mermaid Animations */
        @keyframes waveRipple {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
        }
        
        @keyframes logoWave {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes pearlShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes underwaterCurrent {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        @keyframes particleFloat {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
            100% { transform: translateY(0px) rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ RinaWarp Terminal - AI-Powered Terminal</h1>
        <div class="status" id="status">Initializing AI-powered terminal...</div>
    </div>
    
    <div class="controls">
        <button onclick="startVoiceControl()">üé§ Voice Control <span class="voice-indicator" id="voiceIndicator"></span></button>
        <button onclick="showAIHelp()">ü§ñ AI Commands</button>
        <button onclick="runCommand()">‚ö° Quick Command</button>
        <button onclick="clearTerminal()">üóëÔ∏è Clear Terminal</button>
        <button onclick="showFeatures()">‚ú® Features</button>
    </div>
    
    <div class="ai-section">
        <h3>üí¨ AI Assistant - Talk to Your Terminal</h3>
        <p>Type natural language commands or use voice control:</p>
        <input type="text" id="aiInput" placeholder="Try: 'list all files', 'current directory', 'git status', 'show processes'" />
        <button onclick="processAICommand()">Process Command</button>
        <div id="aiResponse" style="margin-top: 15px; color: #00ff88; font-weight: bold;"></div>
    </div>
    
    <div class="terminal-container">
        <div id="terminal"></div>
    </div>
    
    <div class="version-info">
        RinaWarp Terminal v1.0.7 - AI Edition
    </div>

    <script src="voice-recognition-advanced.js"></script>
    <script src="rina-personality-engine.js"></script>
    <script src="rina-dialogue-system.js"></script>
    <script>
        const { ipcRenderer } = require('electron');
        const { Terminal } = require('@xterm/xterm');
        const { FitAddon } = require('@xterm/addon-fit');
        const { spawn } = require('child_process');
        
        let terminal;
        let shellProcess;
        let isVoiceActive = false;
        let recognition;
        let speechEngine;
        let voiceEngine;
        let aiAssistant;
        let advancedVoiceRecognition;
        let rinaPersonality;
        let rinaDialogue;
        
        // Enhanced Natural Language Processor - Much Smarter AI!
        const nlp = {
            // File operations - expanded
            'list files': 'Get-ChildItem',
            'show files': 'Get-ChildItem',
            'list all files': 'Get-ChildItem -Force',
            'show hidden files': 'Get-ChildItem -Force',
            'find files': 'Get-ChildItem -Recurse',
            'search files': 'Get-ChildItem -Recurse -Filter',
            'list directories': 'Get-ChildItem -Directory',
            'show folders': 'Get-ChildItem -Directory',
            'file count': '(Get-ChildItem).Count',
            'folder size': 'Get-ChildItem | Measure-Object -Property Length -Sum',
            'recent files': 'Get-ChildItem | Sort-Object LastWriteTime -Descending | Select-Object -First 10',
            'large files': 'Get-ChildItem -Recurse | Sort-Object Length -Descending | Select-Object -First 10',
            'empty folders': 'Get-ChildItem -Directory | Where-Object {(Get-ChildItem $_.FullName).Count -eq 0}',
            
            // Directory navigation - expanded
            'current directory': 'Get-Location',
            'where am i': 'Get-Location',
            'show directory': 'pwd',
            'current path': 'Get-Location',
            'working directory': 'Get-Location',
            'go home': 'Set-Location ~',
            'go to desktop': 'Set-Location ~/Desktop',
            'go to documents': 'Set-Location ~/Documents',
            'go to downloads': 'Set-Location ~/Downloads',
            'go to pictures': 'Set-Location ~/Pictures',
            'go up': 'Set-Location ..',
            'go back': 'Set-Location ..',
            'parent directory': 'Set-Location ..',
            'go to root': 'Set-Location C:/',
            'directory tree': 'tree /f',
            'directory structure': 'tree',
            
            // File management - expanded
            'create folder': 'New-Item -ItemType Directory -Name',
            'make directory': 'New-Item -ItemType Directory -Name',
            'create file': 'New-Item -ItemType File -Name',
            'make file': 'New-Item -ItemType File -Name',
            'delete file': 'Remove-Item',
            'remove file': 'Remove-Item',
            'copy file': 'Copy-Item',
            'move file': 'Move-Item',
            'rename file': 'Rename-Item',
            'file properties': 'Get-ItemProperty',
            'file permissions': 'Get-Acl',
            'file size': 'Get-ChildItem | Select-Object Name, Length',
            'compress files': 'Compress-Archive',
            'extract files': 'Expand-Archive',
            'backup files': 'Copy-Item -Recurse',
            
            // System information - expanded
            'show processes': 'Get-Process',
            'list processes': 'Get-Process',
            'running processes': 'Get-Process',
            'top processes': 'Get-Process | Sort-Object CPU -Descending | Select-Object -First 10',
            'memory processes': 'Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 10',
            'kill process': 'Stop-Process -Name',
            'system info': 'Get-ComputerInfo',
            'computer info': 'Get-ComputerInfo',
            'disk space': 'Get-PSDrive',
            'drives': 'Get-PSDrive -PSProvider FileSystem',
            'memory usage': 'Get-WmiObject Win32_OperatingSystem | Select-Object TotalPhysicalMemory, FreePhysicalMemory',
            'cpu info': 'Get-WmiObject Win32_Processor',
            'cpu usage': 'Get-Counter "\\Processor(_Total)\\% Processor Time"',
            'system uptime': 'Get-WmiObject Win32_OperatingSystem | Select-Object LastBootUpTime',
            'installed programs': 'Get-WmiObject Win32_Product',
            'windows version': 'Get-WmiObject Win32_OperatingSystem',
            'environment variables': 'Get-ChildItem Env:',
            'temp files': 'Get-ChildItem $env:TEMP',
            'services': 'Get-Service',
            'running services': 'Get-Service | Where-Object Status -eq Running',
            'startup programs': 'Get-WmiObject Win32_StartupCommand',
            
            // Git operations - expanded
            'git status': 'git status',
            'git log': 'git log --oneline -10',
            'git history': 'git log --oneline -20',
            'git branches': 'git branch -a',
            'git remote': 'git remote -v',
            'git add all': 'git add .',
            'git stage all': 'git add .',
            'git commit': 'git commit -m',
            'git push': 'git push',
            'git pull': 'git pull',
            'git fetch': 'git fetch',
            'git diff': 'git diff',
            'git stash': 'git stash',
            'git merge': 'git merge',
            'git checkout': 'git checkout',
            'git clone': 'git clone',
            'git init': 'git init',
            'git config': 'git config --list',
            'uncommitted changes': 'git status --porcelain',
            'recent commits': 'git log --oneline -5',
            
            // Development - expanded
            'install package': 'npm install',
            'install dependencies': 'npm install',
            'npm install': 'npm install',
            'yarn install': 'yarn install',
            'run tests': 'npm test',
            'test': 'npm test',
            'start server': 'npm start',
            'build project': 'npm run build',
            'run dev': 'npm run dev',
            'dev server': 'npm run dev',
            'package info': 'npm list',
            'outdated packages': 'npm outdated',
            'update packages': 'npm update',
            'npm scripts': 'npm run',
            'node version': 'node --version',
            'npm version': 'npm --version',
            'python version': 'python --version',
            'java version': 'java -version',
            'docker ps': 'docker ps',
            'docker images': 'docker images',
            'docker containers': 'docker ps -a',
            
            // Network - expanded
            'ping google': 'ping google.com',
            'ping test': 'ping 8.8.8.8',
            'show ip': 'ipconfig',
            'ip address': 'ipconfig',
            'network info': 'ipconfig /all',
            'network config': 'ipconfig /all',
            'dns info': 'nslookup',
            'network connections': 'netstat -an',
            'open ports': 'netstat -an | findstr LISTENING',
            'network adapters': 'Get-NetAdapter',
            'wifi networks': 'netsh wlan show profiles',
            'internet speed': 'Test-NetConnection',
            'trace route': 'tracert google.com',
            'flush dns': 'ipconfig /flushdns',
            
            // Windows specific - expanded
            'event logs': 'Get-EventLog System -Newest 10',
            'error logs': 'Get-EventLog System -EntryType Error -Newest 10',
            'windows updates': 'Get-HotFix',
            'installed updates': 'Get-HotFix',
            'registry query': 'Get-ItemProperty',
            'system files': 'sfc /scannow',
            'disk check': 'chkdsk C:',
            'defrag disk': 'defrag C: /A',
            'system restore': 'rstrui',
            'task manager': 'taskmgr',
            'device manager': 'devmgmt.msc',
            'control panel': 'control',
            'system properties': 'sysdm.cpl',
            'msconfig': 'msconfig',
            'regedit': 'regedit',
            
            // File search - expanded
            'find file': 'Get-ChildItem -Recurse -Name',
            'search for': 'Get-ChildItem -Recurse -Filter',
            'locate': 'Get-ChildItem -Recurse -Name',
            'where is': 'Get-ChildItem -Recurse -Name',
            'find text': 'Select-String -Path',
            'grep': 'Select-String',
            'search content': 'Select-String -Recurse',
            
            // Time and date
            'current time': 'Get-Date',
            'date': 'Get-Date',
            'time': 'Get-Date',
            'timestamp': 'Get-Date -Format "yyyy-MM-dd HH:mm:ss"',
            'timezone': 'Get-TimeZone',
            
            // Utilities
            'calculator': 'calc',
            'notepad': 'notepad',
            'paint': 'mspaint',
            'wordpad': 'write',
            'browser': 'start chrome',
            'file explorer': 'explorer',
            'command prompt': 'cmd',
            'powershell': 'powershell',
            
            // System cleanup
            'temp cleanup': 'Get-ChildItem $env:TEMP | Remove-Item -Recurse -Force',
            'recycle bin': 'Clear-RecycleBin',
            'disk cleanup': 'cleanmgr',
            
            // Help and information
            'help': 'Get-Help',
            'commands': 'Get-Command',
            'clear screen': 'Clear-Host',
            'clear': 'Clear-Host',
            'cls': 'Clear-Host',
            'exit': 'exit',
            'quit': 'exit',
            'version': '$PSVersionTable',
            'powershell version': '$PSVersionTable.PSVersion',
            
            // Fun commands
            'weather': 'curl wttr.in',
            'joke': 'curl -s https://api.jokes.one/jod',
            'quote': 'curl -s https://api.quotable.io/random',
            'ascii art': 'figlet',
            
            // Docker (if installed)
            'docker version': 'docker --version',
            'docker info': 'docker info',
            'docker containers': 'docker ps -a',
            'running containers': 'docker ps',
            'docker images': 'docker images',
            'docker volumes': 'docker volume ls',
            'docker networks': 'docker network ls'
        };
        
        // Advanced pattern matching for more intelligent responses
        function findBestMatch(input) {
            const words = input.toLowerCase().split(' ');
            let bestMatch = null;
            let bestScore = 0;
            
            for (const [phrase, command] of Object.entries(nlp)) {
                const phraseWords = phrase.split(' ');
                let score = 0;
                
                // Exact phrase match gets highest score
                if (input.includes(phrase)) {
                    score = 100;
                }
                // Partial word matches
                else {
                    phraseWords.forEach(phraseWord => {
                        words.forEach(inputWord => {
                            if (inputWord === phraseWord) {
                                score += 20;
                            } else if (inputWord.includes(phraseWord) || phraseWord.includes(inputWord)) {
                                score += 10;
                            }
                        });
                    });
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = { phrase, command, score };
                }
            }
            
            return bestMatch && bestMatch.score > 15 ? bestMatch : null;
        }
        
        async function initTerminal() {
            updateStatus('üöÄ Creating AI-powered terminal...');
            
            try {
                // Initialize terminal with proper error handling
                terminal = new Terminal({
                    fontFamily: 'Consolas, "Courier New", monospace',
                    fontSize: 14,
                    cursorBlink: true,
                    theme: {
                        background: '#000000',
                        foreground: '#ffffff',
                        cursor: '#00ff88',
                        selection: 'rgba(0,255,136,0.3)',
                        black: '#000000',
                        red: '#ff6b6b',
                        green: '#00ff88',
                        yellow: '#ffd93d',
                        blue: '#74c0fc',
                        magenta: '#ff79c6',
                        cyan: '#8be9fd',
                        white: '#f8f8f2'
                    }
                });
                
                // Create and load fit addon
                const fitAddon = new FitAddon();
                terminal.loadAddon(fitAddon);
                
                // Open terminal in DOM
                const terminalElement = document.getElementById('terminal');
                if (!terminalElement) {
                    throw new Error('Terminal element not found');
                }
                terminal.open(terminalElement);
                
                // Fit terminal to container
                fitAddon.fit();
                
                // Store fitAddon for later use
                terminal._fitAddon = fitAddon;
            
            updateStatus('üîß Starting PowerShell with AI integration...');
            
            // Start PowerShell
            try {
                const shell = await ipcRenderer.invoke('get-shell');
                
                shellProcess = spawn(shell, ['-NoLogo'], {
                    stdio: ['pipe', 'pipe', 'pipe'],
                    cwd: process.cwd()
                });
                
                shellProcess.stdout.on('data', (data) => {
                    terminal.write(data.toString());
                });
                
                shellProcess.stderr.on('data', (data) => {
                    terminal.write(data.toString());
                });
                
                // Set up data handler with error checking
                if (typeof terminal.onData === 'function') {
                    terminal.onData((data) => {
                        if (shellProcess && shellProcess.stdin) {
                            shellProcess.stdin.write(data);
                        }
                    });
                } else {
                    console.warn('terminal.onData not available, using fallback');
                    // Fallback for older xterm versions
                    if (typeof terminal.on === 'function') {
                        terminal.on('data', (data) => {
                            if (shellProcess && shellProcess.stdin) {
                                shellProcess.stdin.write(data);
                            }
                        });
                    } else {
                        console.error('No data handler method available on terminal');
                    }
                }
                
                shellProcess.on('spawn', () => {
                    updateStatus('‚úÖ RinaWarp Terminal ready! Use AI commands above or type directly.');
                    terminal.write('\r\nüéâ Welcome to RinaWarp Terminal!\r\n');
                    terminal.write('üí° Try the AI assistant above or type PowerShell commands\r\n');
                    terminal.write('üé§ Click "Voice Control" to talk to your terminal\r\n\r\n');
                });
                
                shellProcess.on('error', (error) => {
                    updateStatus(`‚ùå Shell error: ${error.message}`);
                });
                
            } catch (error) {
                updateStatus(`‚ùå Failed to start shell: ${error.message}`);
                terminal.write('\r\n‚ùå Failed to start PowerShell. You can still use the AI features above.\r\n');
            }
            
            // Focus terminal
            terminal.focus();
            
            } catch (terminalError) {
                console.error('Failed to initialize terminal:', terminalError);
                updateStatus(`‚ùå Terminal initialization failed: ${terminalError.message}`);
                
                // Create fallback terminal display
                const terminalElement = document.getElementById('terminal');
                if (terminalElement) {
                    terminalElement.innerHTML = 
                        '<div style="color: #ff6b6b; padding: 20px; text-align: center; font-family: monospace;">' +
                        '‚ùå Terminal failed to initialize<br><br>' +
                        'Error: ' + terminalError.message + '<br><br>' +
                        'The AI assistant above is still available for commands.<br>' +
                        'Please refresh the page to try again.' +
                        '</div>';
                }
                return;
            }
            
            // Resize handler with error checking
            window.addEventListener('resize', () => {
                try {
                    if (terminal && terminal._fitAddon) {
                        terminal._fitAddon.fit();
                    }
                } catch (resizeError) {
                    console.warn('Terminal resize failed:', resizeError);
                }
            });
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('[Status]', message);
        }
        
        async function processAICommand() {
            const input = document.getElementById('aiInput').value.trim();
            const responseDiv = document.getElementById('aiResponse');
            
            if (!input) {
                responseDiv.innerHTML = 'üßú‚Äç‚ôÄÔ∏è <em>*flips tail impatiently*</em> Come on darling, give me something to work with!';
                return;
            }
            
            // Show processing
            responseDiv.innerHTML = 'üåä <em>Swimming through the data currents...</em>';
            
            try {
                let result;
                
                // Use voice-enabled AI if available
                if (aiAssistant) {
                    result = await aiAssistant.processCommand(input);
                    
                    responseDiv.innerHTML = `
                        <div style="color: #FF1493; font-weight: bold;">${result.response}</div>
                        ${result.confidence ? `<div style="color: #00AAFF; font-size: 12px; margin-top: 5px;">Confidence: ${Math.round(result.confidence * 100)}%</div>` : ''}
                    `;
                } else {
                    // Fallback to original logic
                    if (window.aiManager && window.aiManager.isInitialized) {
                        const aiResult = await window.aiManager.processUserCommand(input, {
                            timestamp: new Date().toISOString(),
                            sessionId: window.aiManager.sessionId
                        });
                        
                        responseDiv.innerHTML = `
                            <div style="color: #FF1493; font-weight: bold;">${aiResult.response}</div>
                            ${aiResult.explanation ? `<div style="margin-top: 10px; color: #00AAFF;">${aiResult.explanation}</div>` : ''}
                            ${aiResult.tips && aiResult.tips.length > 0 ? 
                                `<div style="margin-top: 10px; color: #00FF88;">
                                    <strong>üí° Mermaid Tips:</strong><br>
                                    ${aiResult.tips.map(tip => `‚Ä¢ ${tip}`).join('<br>')}
                                </div>` : ''}
                            ${aiResult.safety && aiResult.safety.risk_level !== 'low' ? 
                                `<div style="margin-top: 10px; color: #FFD700;">
                                    <strong>‚ö†Ô∏è Safety Notice:</strong> ${aiResult.safety.risk_level} risk detected
                                </div>` : ''}
                        `;
                    } else {
                        // Legacy mode - find matching command
                        const match = findBestMatch(input);
                        
                        if (match) {
                            responseDiv.innerHTML = `
                                <div>üßú‚Äç‚ôÄÔ∏è Mermaid AI: "${match.phrase}" ‚Üí <code>${match.command}</code></div>
                                <div style="margin-top: 5px; color: #74c0fc;">‚ú® Making waves with this command...</div>
                            `;
                            
                            // Execute if terminal is available
                            if (shellProcess && shellProcess.stdin) {
                                shellProcess.stdin.write(match.command + '\r\n');
                                terminal.write(`\r\nüßú‚Äç‚ôÄÔ∏è Mermaid AI Command: ${match.command}\r\n`);
                            }
                        } else {
                            responseDiv.innerHTML = `
                                <div style="color: #FF1493;">üßú‚Äç‚ôÄÔ∏è <em>*adjusts seashell crown*</em> Sorry sweetie, "${input}" isn't in my underwater vocabulary!</div>
                                <div style="color: #ffd93d; margin-top: 10px;">üêö Try asking about: git, docker, npm, files, or system info</div>
                                <div style="color: #00AAFF; margin-top: 5px;">üí° Or just say "help" for my full repertoire of oceanic wisdom!</div>
                            `;
                        }
                    }
                }
                
                // Add some mermaid flair to successful responses
                if (!responseDiv.innerHTML.includes('Sorry') && !responseDiv.innerHTML.includes('understand')) {
                    const mermiaidEmojis = ['üåä', 'üßú‚Äç‚ôÄÔ∏è', 'üêö', 'üêô', 'üê≥', 'üå∫', '‚ú®'];
                    const randomEmoji = mermiaidEmojis[Math.floor(Math.random() * mermiaidEmojis.length)];
                    responseDiv.innerHTML += `<div style="text-align: right; margin-top: 10px; opacity: 0.7;">${randomEmoji}</div>`;
                }
                
            } catch (error) {
                console.error('AI processing error:', error);
                responseDiv.innerHTML = `
                    <div style="color: #FF6B6B;">üßú‚Äç‚ôÄÔ∏è <em>*bubbles of confusion*</em> Even mermaids have off days!</div>
                    <div style="color: #FFD93D; margin-top: 5px;">Error: ${error.message}</div>
                `;
            }
            
            // Clear input
            document.getElementById('aiInput').value = '';
        }
        
        function startVoiceControl() {
            if (!advancedVoiceRecognition) {
                updateStatus('‚ùå Voice systems not initialized. Please refresh the page.');
                return;
            }

            try {
                const providerInfo = advancedVoiceRecognition.getProviderInfo();
                
                if (!providerInfo.isListening) {
                    advancedVoiceRecognition.start();
                    if (aiAssistant) {
                        aiAssistant.enableVoiceMode();
                    }
                } else {
                    advancedVoiceRecognition.stop();
                    if (aiAssistant) {
                        aiAssistant.disableVoiceMode();
                    }
                }
            } catch (error) {
                console.error('Voice control error:', error);
                updateStatus(`‚ùå Voice control error: ${error.message}`);
            }
        }
        
        function showAIHelp() {
            const helpText = `
ü§ñ RinaWarp AI Assistant Commands:

üìÅ FILE OPERATIONS:
‚Ä¢ "list files" - Show files in directory
‚Ä¢ "show hidden files" - Include hidden files
‚Ä¢ "find files" - Search recursively

üìÇ NAVIGATION:
‚Ä¢ "current directory" - Show where you are
‚Ä¢ "go home" - Navigate to home directory
‚Ä¢ "go to desktop" - Navigate to Desktop

üîß SYSTEM:
‚Ä¢ "show processes" - List running processes
‚Ä¢ "system info" - Computer information
‚Ä¢ "disk space" - Show drive usage

üî® DEVELOPMENT:
‚Ä¢ "git status" - Check git repository
‚Ä¢ "install package" - Run npm install
‚Ä¢ "run tests" - Execute npm test

üé§ VOICE:
‚Ä¢ Say "Hey Rina" + any command above
‚Ä¢ Example: "Hey Rina, list files"

üí° TIP: You can also type PowerShell commands directly in the terminal!
            `;
            alert(helpText);
        }
        
        async function runCommand() {
            const cmd = await new Promise(resolve => {
                const inputModal = document.createElement('div');
                inputModal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.8); display: flex; align-items: center;
                    justify-content: center; z-index: 1000;
                `;
                inputModal.innerHTML = `
                    <div style="background: #2d2d2d; padding: 30px; border-radius: 10px; max-width: 400px; width: 100%; text-align: center;">
                        <h4 style="color: #00ff88; margin-top: 0;">Enter PowerShell Command</h4>
                        <input type="text" id="commandInput" style="width: 80%; padding: 10px; margin-bottom: 10px;">
                        <button id="runCmdButton" style="padding: 10px 20px; background: #007acc; color: white; border: none; border-radius: 5px; cursor: pointer;">Run</button>
                        <button id="closeCmdButton" style="padding: 10px 20px; background: #999; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">Close</button>
                    </div>
                `;
                document.body.appendChild(inputModal);

                document.getElementById('commandInput').focus();

                document.getElementById('runCmdButton').onclick = () => {
                    const command = document.getElementById('commandInput').value;
                    document.body.removeChild(inputModal);
                    resolve(command);
                };

                document.getElementById('closeCmdButton').onclick = () => {
                    document.body.removeChild(inputModal);
                    resolve(null);
                };
            });
            if (cmd && shellProcess && shellProcess.stdin) {
                shellProcess.stdin.write(cmd + '\r\n');
                terminal.write(`\r\n‚ö° Quick Command: ${cmd}\r\n`);
            }
        }
        
        function clearTerminal() {
            if (terminal) {
                terminal.clear();
                terminal.write('üßπ Terminal cleared\r\n\r\n');
            }
        }
        
        function showFeatures() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; align-items: center;
                justify-content: center; z-index: 1000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: #2d2d2d; padding: 30px; border-radius: 10px;
                    max-width: 600px; max-height: 80%; overflow-y: auto;
                    border: 2px solid #555;
                ">
                    <h2 style="color: #00ff88; margin-top: 0;">‚ú® RinaWarp Terminal Features</h2>
                    
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>ü§ñ AI Assistant</h4>
                            <p>Natural language commands</p>
                        </div>
                        <div class="feature-card">
                            <h4>üé§ Voice Control</h4>
                            <p>Talk to your terminal</p>
                        </div>
                        <div class="feature-card">
                            <h4>‚ö° PowerShell</h4>
                            <p>Full Windows PowerShell</p>
                        </div>
                        <div class="feature-card">
                            <h4>üé® Modern UI</h4>
                            <p>Beautiful interface</p>
                        </div>
                    </div>
                    
                    <h3 style="color: #74c0fc;">üöÄ Coming Soon:</h3>
                    <ul style="color: #ffd93d;">
                        <li>Cloud sync across devices</li>
                        <li>Team collaboration features</li>
                        <li>Advanced AI workflows</li>
                        <li>Custom themes and plugins</li>
                    </ul>
                    
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="margin-top: 20px; padding: 10px 20px; background: #007acc; 
                                   color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // Handle enter key in AI input
        document.addEventListener('DOMContentLoaded', () => {
            const aiInput = document.getElementById('aiInput');
            aiInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    processAICommand();
                }
            });
            
            // Focus on AI input by default
            aiInput.focus();
        });
        
        // Initialize terminal when page loads
        window.addEventListener('DOMContentLoaded', initTerminal);
        
        // Prevent context menu for cleaner experience
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Enhanced Speech Recognition Engine with Multiple Providers
        class SpeechRecognitionEngine {
            constructor() {
                this.isListening = false;
                this.recognition = null;
                this.wakeWords = ['hey rina', 'hello rina', 'rina'];
                this.stopWords = ['stop listening', 'stop voice', 'stop rina'];
                this.confidence = 0;
                this.lastCommand = '';
                this.onCommand = null;
                this.onStatusChange = null;
                this.provider = 'web-speech'; // 'web-speech', 'mock', 'keyboard'
                this.errorCount = 0;
                this.maxErrors = 3;
                this.isInitialized = false;
            }

            async init() {
                console.log('Initializing speech recognition...');
                
                // Try Web Speech API first
                if (this.tryWebSpeechAPI()) {
                    this.provider = 'web-speech';
                    console.log('Using Web Speech API');
                    return true;
                }
                
                // Fallback to mock/keyboard input
                console.warn('Web Speech API not available, using keyboard fallback');
                this.provider = 'keyboard';
                this.setupKeyboardFallback();
                return true;
            }

            tryWebSpeechAPI() {
                try {
                    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                        return false;
                    }

                    this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'en-US';
                    this.recognition.maxAlternatives = 3;

                    // Add Electron-specific configurations
                    if (typeof process !== 'undefined' && process.versions && process.versions.electron) {
                        console.log('Detected Electron environment, applying workarounds...');
                        // Some Electron-specific settings that might help
                        this.recognition.serviceURI = 'wss://www.google.com/speech-api/full-duplex/v1/up';
                    }

                    this.recognition.onstart = () => {
                        this.isListening = true;
                        this.errorCount = 0;
                        if (this.onStatusChange) this.onStatusChange('listening');
                    };

                    this.recognition.onresult = (event) => {
                        this.handleResult(event);
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        this.errorCount++;
                        
                        // Handle specific errors
                        switch(event.error) {
                            case 'network':
                                if (this.errorCount >= this.maxErrors) {
                                    console.warn('Too many network errors, switching to keyboard fallback');
                                    this.switchToKeyboardFallback();
                                    return;
                                }
                                break;
                            case 'not-allowed':
                                if (this.onStatusChange) {
                                    this.onStatusChange('error', 'microphone-denied');
                                }
                                return;
                            case 'no-speech':
                                // Auto-restart for no-speech errors
                                setTimeout(() => {
                                    if (!this.isListening) {
                                        this.start();
                                    }
                                }, 1000);
                                break;
                        }
                        
                        if (this.onStatusChange) this.onStatusChange('error', event.error);
                    };

                    this.recognition.onend = () => {
                        this.isListening = false;
                        if (this.onStatusChange) this.onStatusChange('stopped');
                        
                        // Auto-restart if we're supposed to be listening
                        if (this.provider === 'web-speech' && this.errorCount < this.maxErrors) {
                            setTimeout(() => {
                                if (!this.isListening) {
                                    this.start();
                                }
                            }, 500);
                        }
                    };

                    this.isInitialized = true;
                    return true;
                } catch (error) {
                    console.error('Failed to initialize Web Speech API:', error);
                    return false;
                }
            }

            setupKeyboardFallback() {
                console.log('Setting up keyboard fallback for voice commands');
                
                // Add a visual indicator that we're in keyboard mode
                this.showKeyboardModeUI();
                
                // Set up keyboard shortcut (Ctrl+Shift+V for voice command)
                document.addEventListener('keydown', (event) => {
                    if (event.ctrlKey && event.shiftKey && event.key === 'V') {
                        event.preventDefault();
                        this.promptForVoiceCommand();
                    }
                });
                
                this.isInitialized = true;
            }

            showKeyboardModeUI() {
                // Update the voice control button to show keyboard mode
                const voiceButton = document.querySelector('button[onclick="startVoiceControl()"]');
                if (voiceButton) {
                    voiceButton.innerHTML = '‚å®Ô∏è Voice (Keyboard) <span class="voice-indicator" id="voiceIndicator"></span>';
                    voiceButton.title = 'Press Ctrl+Shift+V for voice command input';
                }
                
                // Show notification
                if (this.onStatusChange) {
                    this.onStatusChange('keyboard-mode');
                }
            }

            promptForVoiceCommand() {
                const command = prompt('üé§ Voice Command (type your command):\n\nExamples:\n‚Ä¢ list files\n‚Ä¢ current directory\n‚Ä¢ git status\n‚Ä¢ show processes');
                
                if (command && command.trim()) {
                    // Simulate voice command processing
                    this.handleVoiceInput(command.trim(), 1.0);
                }
            }

            switchToKeyboardFallback() {
                console.log('Switching to keyboard fallback due to speech recognition issues');
                this.provider = 'keyboard';
                this.isListening = false;
                
                if (this.recognition) {
                    this.recognition.stop();
                }
                
                this.setupKeyboardFallback();
                
                // Notify user
                alert('üé§‚û°Ô∏è‚å®Ô∏è Voice recognition switched to keyboard mode due to connection issues.\n\nUse Ctrl+Shift+V to input voice commands via keyboard.');
            }

            handleVoiceInput(transcript, confidence) {
                console.log('Processing voice input:', transcript, 'Confidence:', confidence);
                
                // Check for wake words and extract command
                let command = null;
                const lowerTranscript = transcript.toLowerCase();
                
                for (const wakeWord of this.wakeWords) {
                    if (lowerTranscript.includes(wakeWord)) {
                        command = lowerTranscript.replace(wakeWord, '').trim();
                        break;
                    }
                }
                
                // In keyboard mode, assume direct command input
                if (this.provider === 'keyboard' && !command) {
                    command = transcript;
                }
                
                if (command && this.onCommand) {
                    this.onCommand(command, confidence);
                }
            }

            handleResult(event) {
                const result = event.results[event.results.length - 1];
                const transcript = result[0].transcript.toLowerCase().trim();
                this.confidence = result[0].confidence;
                this.lastCommand = transcript;

                console.log('Speech result:', transcript, 'Confidence:', this.confidence);

                // Check for stop commands
                if (this.stopWords.some(word => transcript.includes(word))) {
                    this.stop();
                    return;
                }

                // Check for wake words and extract command
                let command = null;
                for (const wakeWord of this.wakeWords) {
                    if (transcript.includes(wakeWord)) {
                        command = transcript.replace(wakeWord, '').trim();
                        break;
                    }
                }

                if (command && this.onCommand && result.isFinal) {
                    this.onCommand(command, this.confidence);
                }
            }

            async start() {
                if (!this.isInitialized) {
                    await this.init();
                }
                
                if (this.provider === 'web-speech') {
                    if (this.recognition && !this.isListening) {
                        try {
                            this.recognition.start();
                        } catch (error) {
                            console.error('Failed to start speech recognition:', error);
                            this.switchToKeyboardFallback();
                        }
                    }
                } else if (this.provider === 'keyboard') {
                    // In keyboard mode, clicking the button opens the prompt
                    this.promptForVoiceCommand();
                }
            }

            stop() {
                if (this.provider === 'web-speech' && this.recognition && this.isListening) {
                    this.recognition.stop();
                }
                this.isListening = false;
            }

            toggle() {
                if (this.isListening) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        // Voice Synthesis Engine
        class VoiceSynthesisEngine {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voice = null;
                this.customVoice = null;
                this.settings = {
                    rate: 1.0,
                    pitch: 1.0,
                    volume: 0.8,
                    useCustomVoice: false
                };
                this.isInitialized = false;
            }

            async init() {
                if (!this.synth) {
                    throw new Error('Speech synthesis not supported');
                }

                // Wait for voices to load
                return new Promise((resolve) => {
                    const loadVoices = () => {
                        const voices = this.synth.getVoices();
                        if (voices.length > 0) {
                            this.voice = voices.find(v => v.lang.startsWith('en-')) || voices[0];
                            this.isInitialized = true;
                            console.log('Voice synthesis initialized with voice:', this.voice.name);
                            resolve();
                        } else {
                            setTimeout(loadVoices, 100);
                        }
                    };
                    loadVoices();
                });
            }

            speak(text, options = {}) {
                if (!this.isInitialized) {
                    console.warn('Voice synthesis not initialized');
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = this.voice;
                utterance.rate = options.rate || this.settings.rate;
                utterance.pitch = options.pitch || this.settings.pitch;
                utterance.volume = options.volume || this.settings.volume;

                // Add some personality to Rina's voice
                if (text.includes('üßú‚Äç‚ôÄÔ∏è') || text.includes('mermaid')) {
                    utterance.pitch = 1.2;
                    utterance.rate = 0.9;
                }

                this.synth.speak(utterance);
                return utterance;
            }

            stop() {
                this.synth.cancel();
            }

            setVoice(voiceName) {
                const voices = this.synth.getVoices();
                this.voice = voices.find(v => v.name === voiceName) || this.voice;
            }

            getVoices() {
                return this.synth.getVoices();
            }
        }

        // AI Assistant with Voice Integration
        class VoiceEnabledAI {
            constructor(speechEngine, voiceEngine) {
                this.speechEngine = speechEngine;
                this.voiceEngine = voiceEngine;
                this.isVoiceMode = false;
                this.conversationHistory = [];
            }

            async processCommand(command, confidence = 1.0) {
                console.log('Processing AI command:', command, 'Confidence:', confidence);
                
                // Add to conversation history
                this.conversationHistory.push({
                    type: 'user',
                    text: command,
                    confidence: confidence,
                    timestamp: new Date().toISOString()
                });

                let response;
                let shouldSpeak = true;

                try {
                    // Check if advanced AI is available
                    if (window.aiManager && window.aiManager.isInitialized) {
                        const aiResult = await window.aiManager.processUserCommand(command, {
                            timestamp: new Date().toISOString(),
                            sessionId: window.aiManager.sessionId,
                            voiceMode: this.isVoiceMode,
                            confidence: confidence
                        });
                        response = aiResult.response;
                    } else {
                        // Use enhanced pattern matching
                        const match = findBestMatch(command);
                        if (match) {
                            response = `Executing: ${match.command}`;
                            // Execute the command if terminal is available
                            if (shellProcess && shellProcess.stdin) {
                                shellProcess.stdin.write(match.command + '\r\n');
                                terminal.write(`\r\nüßú‚Äç‚ôÄÔ∏è Voice Command: ${match.command}\r\n`);
                            }
                        } else {
                            response = `Sorry, I didn't understand "${command}". Try commands like "list files" or "git status".`;
                        }
                    }

                    // Add response to history
                    this.conversationHistory.push({
                        type: 'assistant',
                        text: response,
                        timestamp: new Date().toISOString()
                    });

                    // Speak the response if voice mode is active
                    if (this.isVoiceMode && shouldSpeak && this.voiceEngine) {
                        // Clean response for speech (remove emojis and markdown)
                        const cleanResponse = response
                            .replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄ]/g, '')
                            .replace(/\*([^*]+)\*/g, '$1')
                            .replace(/`([^`]+)`/g, '$1')
                            .trim();
                        
                        this.voiceEngine.speak(cleanResponse);
                    }

                    return {
                        response: response,
                        confidence: confidence,
                        executed: !!match
                    };

                } catch (error) {
                    console.error('AI processing error:', error);
                    const errorResponse = `Sorry, I encountered an error: ${error.message}`;
                    
                    if (this.isVoiceMode && this.voiceEngine) {
                        this.voiceEngine.speak(errorResponse);
                    }
                    
                    return {
                        response: errorResponse,
                        confidence: 0,
                        error: error.message
                    };
                }
            }

            enableVoiceMode() {
                this.isVoiceMode = true;
                if (this.voiceEngine) {
                    this.voiceEngine.speak('Voice mode enabled. I\'m listening for your commands.');
                }
            }

            disableVoiceMode() {
                this.isVoiceMode = false;
                if (this.voiceEngine) {
                    this.voiceEngine.speak('Voice mode disabled.');
                }
            }
        }

        // Initialize Advanced Voice Systems
        async function initVoiceSystems() {
            try {
                console.log('üé§ Initializing Advanced Voice Recognition System...');
                
                // Initialize Rina's personality engine
                rinaPersonality = new RinaPersonalityEngine();
                console.log('üßú‚Äç‚ôÄÔ∏è Rina\'s personality engine initialized!');
                
                // Initialize Rina's advanced dialogue system
                rinaDialogue = new RinaDialogueSystem();
                console.log('üßú‚Äç‚ôÄÔ∏è Rina\'s dialogue system initialized!');
                
                // Initialize the advanced voice recognition system
                advancedVoiceRecognition = new AdvancedVoiceRecognition();
                
                // Make sure we use the enhanced keyboard provider
                if (window.EnhancedKeyboardProvider) {
                    console.log('Using enhanced keyboard provider for better UX');
                }
                
                // Initialize voice synthesis for responses
                voiceEngine = new VoiceSynthesisEngine();
                await voiceEngine.init();
                
                // Initialize AI assistant with voice
                aiAssistant = new VoiceEnabledAI(advancedVoiceRecognition, voiceEngine);
                
                // Set up event handlers for the advanced voice recognition
                advancedVoiceRecognition.onCommand = async (command, confidence) => {
                    console.log('üé§ Voice command received:', command);
                    document.getElementById('aiInput').value = command;
                    
                    // Check for special personality triggers first
                    const specialTrigger = rinaPersonality.handleSpecialTrigger(command);
                    if (specialTrigger) {
                        const responseDiv = document.getElementById('aiResponse');
                        responseDiv.innerHTML = `
                            <div style="color: #FF1493; font-weight: bold;">${specialTrigger.response}</div>
                            <div style="color: #8A2BE2; font-size: 12px; margin-top: 5px;">
                                Mood: ${specialTrigger.mood || rinaPersonality.mood} | Special Command
                            </div>
                        `;
                        
                        // Speak the response
                        if (voiceEngine) {
                            const cleanResponse = specialTrigger.response.replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄ]/g, '').replace(/\*([^*]+)\*/g, '$1');
                            voiceEngine.speak(cleanResponse);
                        }
                        return;
                    }
                    
                    // Process regular command
                    const result = await aiAssistant.processCommand(command, confidence);
                    
                    // Let Rina add her personality to the response
                    const personalizedResult = rinaPersonality.generateResponse(command, result, { confidence });
                    
                    // Enhance with advanced dialogue system for more contextual responses
                    if (rinaDialogue) {
                        const isSuccess = !result.error && result.executed;
                        const isError = !!result.error;
                        const dialogueContext = {
                            type: isError ? 'error' : (isSuccess ? 'success' : 'greeting'),
                            success: isSuccess,
                            isError: isError,
                            mood: personalizedResult.mood,
                            confidence: confidence || 0.8
                        };
                        
                        // Generate enhanced response using dialogue system
                        const enhancedResponse = rinaDialogue.generateResponse(dialogueContext, personalizedResult.response);
                        personalizedResult.response = enhancedResponse;
                    }
                    
                    // Update UI with provider info and personality
                    const providerInfo = advancedVoiceRecognition.getProviderInfo();
                    const responseDiv = document.getElementById('aiResponse');
                    responseDiv.innerHTML = `
                        <div style="color: #FF1493; font-weight: bold;">${personalizedResult.response}</div>
                        <div style="color: #00AAFF; font-size: 12px; margin-top: 5px;">
                            Provider: ${providerInfo.current} | Confidence: ${Math.round((confidence || 0) * 100)}% | Mood: ${personalizedResult.mood}
                        </div>
                        ${personalizedResult.suggestions.length > 0 ? 
                            `<div style="color: #00FF88; font-size: 11px; margin-top: 5px;">
                                üí° ${personalizedResult.suggestions.join(' ‚Ä¢ ')}
                            </div>` : ''}
                    `;
                    
                    // Speak the personalized response
                    if (voiceEngine && aiAssistant.isVoiceMode) {
                        const cleanResponse = personalizedResult.response.replace(/[üßú‚Äç‚ôÄÔ∏èüåäüêöüé§‚ö°‚ú®üöÄ]/g, '').replace(/\*([^*]+)\*/g, '$1');
                        voiceEngine.speak(cleanResponse);
                    }
                    
                    // Visual feedback for voice command
                    responseDiv.style.border = '2px solid #00ff88';
                    setTimeout(() => {
                        responseDiv.style.border = 'none';
                    }, 1500);
                };
                
                advancedVoiceRecognition.onStatusChange = (status, data) => {
                    const indicator = document.getElementById('voiceIndicator');
                    
                    switch (status) {
                        case 'initialized':
                            const providerName = data.provider === 'keyboard' ? 'Keyboard' : 
                                                data.provider === 'webspeech' ? 'Web Speech' : 
                                                data.provider === 'vosk' ? 'Vosk (Offline)' : data.provider;
                            updateStatus(`‚úÖ Voice recognition ready using ${providerName} provider`);
                            
                            // Update button text based on provider
                            const voiceButton = document.querySelector('button[onclick="startVoiceControl()"]');
                            if (voiceButton) {
                                if (data.provider === 'keyboard') {
                                    voiceButton.innerHTML = '‚å®Ô∏è Voice (Keyboard) <span class="voice-indicator" id="voiceIndicator"></span>';
                                    voiceButton.title = 'Press Ctrl+Shift+V for voice command input';
                                } else {
                                    voiceButton.innerHTML = 'üé§ Voice Control <span class="voice-indicator" id="voiceIndicator"></span>';
                                    voiceButton.title = 'Click to start/stop voice recognition';
                                }
                            }
                            break;
                            
                        case 'provider-switched':
                            const fromProvider = data.from === 'keyboard' ? 'Keyboard' : 
                                               data.from === 'webspeech' ? 'Web Speech' : 
                                               data.from === 'vosk' ? 'Vosk' : data.from;
                            const toProvider = data.to === 'keyboard' ? 'Keyboard' : 
                                             data.to === 'webspeech' ? 'Web Speech' : 
                                             data.to === 'vosk' ? 'Vosk' : data.to;
                            updateStatus(`üîÑ Voice provider switched from ${fromProvider} to ${toProvider}`);
                            
                            // Show user notification
                            if (data.to === 'keyboard') {
                                alert('üé§‚û°Ô∏è‚å®Ô∏è Voice recognition switched to keyboard mode due to connection issues.\n\nUse Ctrl+Shift+V to input voice commands via keyboard.');
                            }
                            break;
                            
                        case 'listening':
                            indicator.classList.add('active');
                            updateStatus('üé§ Voice control active - say "Hey Rina" followed by your command');
                            break;
                            
                        case 'stopped':
                            indicator.classList.remove('active');
                            updateStatus('üé§ Voice control stopped');
                            break;
                            
                        case 'error':
                            indicator.classList.remove('active');
                            updateStatus(`‚ùå Voice error: ${data || 'Unknown error'}`);
                            break;
                    }
                };
                
                // Initialize the advanced voice recognition system
                await advancedVoiceRecognition.init();
                
                console.log('‚úÖ Advanced Voice Recognition System initialized successfully');
                return true;
                
            } catch (error) {
                console.error('Failed to initialize voice systems:', error);
                updateStatus(`‚ùå Voice systems unavailable: ${error.message}`);
                return false;
            }
        }

        // Load AI Integration
        async function loadAIIntegration() {
            try {
                const { AIIntegrationManager } = await import('./ai-integration.js');
                window.aiManager = new AIIntegrationManager();
                console.log('üßú‚Äç‚ôÄÔ∏è AI Integration loaded successfully!');
            } catch (error) {
                console.warn('AI Integration not available:', error);
                // Set up basic fallback
                window.processAICommand = async (command) => {
                    return {
                        response: 'üßú‚Äç‚ôÄÔ∏è Basic mermaid AI: ' + command,
                        suggestions: []
                    };
                };
            }
        }
        
        // Load AI and Voice Systems on page ready
        document.addEventListener('DOMContentLoaded', async () => {
            await loadAIIntegration();
            await initVoiceSystems();
        });
    </script>
</body>
</html>
